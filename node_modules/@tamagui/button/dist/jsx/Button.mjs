import { getFontSize } from "@tamagui/font-size";
import { getButtonSized } from "@tamagui/get-button-sized";
import { useGetThemedIcon } from "@tamagui/helpers-tamagui";
import { ThemeableStack } from "@tamagui/stacks";
import {
  SizableText,
  wrapChildrenInText
} from "@tamagui/text";
import {
  ButtonNestingContext,
  createStyledContext,
  getVariableValue,
  spacedChildren,
  styled,
  useProps,
  withStaticProperties
} from "@tamagui/web";
import { useContext } from "react";
const ButtonContext = createStyledContext({
  size: "$true",
  color: void 0,
  fontFamily: void 0,
  fontSize: void 0,
  fontStyle: void 0,
  fontWeight: void 0,
  letterSpacing: void 0,
  textAlign: void 0
});
const BUTTON_NAME = "Button";
const ButtonFrame = styled(ThemeableStack, {
  name: BUTTON_NAME,
  tag: "button",
  context: ButtonContext,
  focusable: true,
  role: "button",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        justifyContent: "center",
        alignItems: "center",
        flexWrap: "nowrap",
        flexDirection: "row",
        cursor: "pointer",
        hoverTheme: true,
        pressTheme: true,
        backgrounded: true,
        borderWidth: 1,
        borderColor: "$borderColor",
        focusStyle: {
          outlineColor: "$borderColorFocus",
          outlineStyle: "solid",
          outlineWidth: 2
        }
      }
    },
    size: {
      "...size": getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const ButtonText = styled(SizableText, {
  name: "Button",
  context: ButtonContext,
  variants: {
    unstyled: {
      false: {
        userSelect: "none",
        cursor: "pointer",
        // flexGrow 1 leads to inconsistent native style where text pushes to start of view
        flexGrow: 0,
        flexShrink: 1,
        ellipse: true,
        color: "$color"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const ButtonIcon = (props) => {
  const { children, scaleIcon = 1 } = props;
  const { size, color } = useContext(ButtonContext);
  const iconSize = (typeof size === "number" ? size * 0.5 : getFontSize(size)) * scaleIcon;
  const getThemedIcon = useGetThemedIcon({ size: iconSize, color });
  return getThemedIcon(children);
};
const ButtonComponent = ButtonFrame.styleable(function Button(props, ref) {
  const { props: buttonProps } = useButton(props);
  return <ButtonFrame {...buttonProps} ref={ref} />;
});
const buttonStaticConfig = {
  inlineProps: /* @__PURE__ */ new Set([
    // text props go here (can't really optimize them, but we never fully extract button anyway)
    // may be able to remove this entirely, as the compiler / runtime have gotten better
    "color",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "fontStyle",
    "letterSpacing",
    "textAlign",
    "unstyled"
  ])
};
const Button2 = withStaticProperties(ButtonComponent, {
  Text: ButtonText,
  Icon: ButtonIcon
});
function useButton(propsIn, { Text = Button2.Text } = { Text: Button2.Text }) {
  const {
    children,
    icon,
    iconAfter,
    noTextWrap,
    theme: themeName,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 0.66,
    separator,
    // text props
    color,
    fontWeight,
    letterSpacing,
    fontSize,
    fontFamily,
    fontStyle,
    textAlign,
    textProps,
    ...rest
  } = propsIn;
  const isNested = useContext(ButtonNestingContext);
  const propsActive = useProps(propsIn);
  const size = propsActive.size || "$true";
  const iconSize = (typeof size === "number" ? size * 0.5 : getFontSize(size)) * scaleIcon;
  const getThemedIcon = useGetThemedIcon({ size: iconSize, color });
  const [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon);
  const spaceSize = propsActive.space ?? getVariableValue(iconSize) * scaleSpace;
  const contents = wrapChildrenInText(
    Text,
    propsActive,
    Text === ButtonText && propsIn.unstyled !== true ? {
      unstyled: true,
      size
    } : void 0
  );
  const inner = spacedChildren({
    // a bit arbitrary but scaling to font size is necessary so long as button does
    space: spaceSize,
    spaceFlex,
    separator,
    direction: propsActive.flexDirection === "column" || propsActive.flexDirection === "column-reverse" ? "vertical" : "horizontal",
    children: [themedIcon, ...contents, themedIconAfter]
  });
  const tag = isNested ? "span" : (
    // defaults to <a /> when accessibilityRole = link
    // see https://github.com/tamagui/tamagui/issues/505
    propsIn.accessibilityRole === "link" ? "a" : void 0
  );
  const props = {
    ...propsActive.disabled && {
      // in rnw - false still has keyboard tabIndex, undefined = not actually focusable
      focusable: void 0,
      // even with tabIndex unset, it will keep focusStyle on web so disable it here
      focusStyle: {
        borderColor: "$background"
      }
    },
    ...tag && {
      tag
    },
    ...rest,
    children: <ButtonNestingContext.Provider value={true}>{inner}</ButtonNestingContext.Provider>
  };
  return {
    spaceSize,
    isNested,
    props
  };
}
export {
  Button2 as Button,
  ButtonContext,
  ButtonFrame,
  ButtonIcon,
  ButtonText,
  buttonStaticConfig,
  useButton
};
//# sourceMappingURL=Button.mjs.map
