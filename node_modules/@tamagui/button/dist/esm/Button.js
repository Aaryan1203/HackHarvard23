import { getFontSize } from "@tamagui/font-size";
import { getButtonSized } from "@tamagui/get-button-sized";
import { useGetThemedIcon } from "@tamagui/helpers-tamagui";
import { ThemeableStack } from "@tamagui/stacks";
import {
  SizableText,
  wrapChildrenInText
} from "@tamagui/text";
import {
  createStyledContext,
  getVariableValue,
  spacedChildren,
  styled,
  useDidFinishSSR,
  useProps,
  withStaticProperties
} from "@tamagui/web";
import { createContext, useContext } from "react";
import { jsx } from "react/jsx-runtime";
const ButtonContext = createStyledContext({
  // keeping these here means they work with styled() passing down color to text
  color: void 0,
  ellipse: void 0,
  fontFamily: void 0,
  fontSize: void 0,
  fontStyle: void 0,
  fontWeight: void 0,
  letterSpacing: void 0,
  maxFontSizeMultiplier: void 0,
  size: void 0,
  textAlign: void 0
}), BUTTON_NAME = "Button", ButtonFrame = styled(ThemeableStack, {
  name: BUTTON_NAME,
  tag: "button",
  context: ButtonContext,
  focusable: !0,
  role: "button",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        justifyContent: "center",
        alignItems: "center",
        flexWrap: "nowrap",
        flexDirection: "row",
        cursor: "pointer",
        hoverTheme: !0,
        pressTheme: !0,
        backgrounded: !0,
        borderWidth: 1,
        borderColor: "transparent",
        focusStyle: {
          outlineColor: "$borderColorFocus",
          outlineStyle: "solid",
          outlineWidth: 2
        }
      }
    },
    variant: {
      outlined: {
        backgroundColor: "transparent",
        borderWidth: 2,
        borderColor: "$borderColor",
        hoverStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorHover"
        },
        pressStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorPress"
        },
        focusStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorFocus"
        }
      }
    },
    size: {
      "...size": getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    unstyled: !1
  }
}), ButtonText = styled(SizableText, {
  name: "Button",
  context: ButtonContext,
  variants: {
    unstyled: {
      false: {
        userSelect: "none",
        cursor: "pointer",
        // flexGrow 1 leads to inconsistent native style where text pushes to start of view
        flexGrow: 0,
        flexShrink: 1,
        ellipse: !0,
        color: "$color"
      }
    }
  },
  defaultVariants: {
    unstyled: !1
  }
}), ButtonIcon = (props) => {
  const { children, scaleIcon = 1 } = props, { size, color } = useContext(ButtonContext), iconSize = (typeof size == "number" ? size * 0.5 : getFontSize(size)) * scaleIcon;
  return useGetThemedIcon({ size: iconSize, color })(children);
}, ButtonComponent = ButtonFrame.styleable(function(props, ref) {
  const { props: buttonProps } = useButton(props);
  return /* @__PURE__ */ jsx(ButtonFrame, { ...buttonProps, ref });
}), buttonStaticConfig = {
  inlineProps: /* @__PURE__ */ new Set([
    // text props go here (can't really optimize them, but we never fully extract button anyway)
    // may be able to remove this entirely, as the compiler / runtime have gotten better
    "color",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "fontStyle",
    "letterSpacing",
    "textAlign",
    "unstyled"
  ])
}, Button2 = withStaticProperties(ButtonComponent, {
  Text: ButtonText,
  Icon: ButtonIcon
}), ButtonNestingContext = createContext(!1);
function useButton({ textProps, ...propsIn }, { Text = Button2.Text } = { Text: Button2.Text }) {
  const isNested = useContext(ButtonNestingContext), didFinishSSR = useDidFinishSSR(), propsActive = useProps(propsIn), {
    icon,
    iconAfter,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 0.66,
    separator,
    noTextWrap,
    fontFamily,
    fontSize
  } = propsActive, size = propsActive.size || (propsActive.unstyled ? void 0 : "$true"), iconSize = (typeof size == "number" ? size * 0.5 : getFontSize(size)) * scaleIcon, getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color: propsActive.color
  }), [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon), spaceSize = space ?? getVariableValue(iconSize) * scaleSpace, contents = noTextWrap ? [propsIn.children] : wrapChildrenInText(
    Text,
    { children: propsIn.children, fontFamily, fontSize, textProps },
    Text === ButtonText && propsActive.unstyled !== !0 ? {
      unstyled: !1,
      size
    } : void 0
  ), inner = spacedChildren({
    // a bit arbitrary but scaling to font size is necessary so long as button does
    space: spaceSize,
    spaceFlex,
    separator,
    direction: propsActive.flexDirection === "column" || propsActive.flexDirection === "column-reverse" ? "vertical" : "horizontal",
    children: [themedIcon, ...contents, themedIconAfter]
  }), tag = isNested ? "span" : (
    // defaults to <a /> when accessibilityRole = link
    // see https://github.com/tamagui/tamagui/issues/505
    propsActive.accessibilityRole === "link" ? "a" : void 0
  ), { iconAfter: _1, icon: _2, noTextWrap: _3, ...restProps } = propsIn, props = {
    size,
    ...propsIn.disabled && {
      // in rnw - false still has keyboard tabIndex, undefined = not actually focusable
      focusable: void 0,
      // even with tabIndex unset, it will keep focusStyle on web so disable it here
      focusStyle: {
        borderColor: "$background"
      }
    },
    ...tag && {
      tag
    },
    ...restProps,
    children: /* @__PURE__ */ jsx(ButtonNestingContext.Provider, { value: !0, children: inner }),
    // forces it to be a runtime pressStyle so it passes through context text colors
    disableClassName: didFinishSSR
  };
  return {
    spaceSize,
    isNested,
    props
  };
}
export {
  Button2 as Button,
  ButtonContext,
  ButtonFrame,
  ButtonIcon,
  ButtonNestingContext,
  ButtonText,
  buttonStaticConfig,
  useButton
};
//# sourceMappingURL=Button.js.map
