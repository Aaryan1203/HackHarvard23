import {
  getTokens,
  getVariableValue,
  styled,
  withStaticProperties
} from "@tamagui/core";
import { createContextScope } from "@tamagui/create-context";
import { Image } from "@tamagui/image";
import { Square, getShapeSize } from "@tamagui/shapes";
import { YStack } from "@tamagui/stacks";
import * as React from "react";
const AVATAR_NAME = "Avatar", [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME), [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME), IMAGE_NAME = "AvatarImage", AvatarImage = React.forwardRef(
  (props, forwardedRef) => {
    var _a;
    const { __scopeAvatar, src, onLoadingStatusChange = () => {
    }, ...imageProps } = props, context = useAvatarContext(IMAGE_NAME, __scopeAvatar), [status, setStatus] = React.useState("idle"), shapeSize = getVariableValue(
      (_a = getShapeSize(
        context.size,
        // @ts-expect-error
        { tokens: getTokens() }
      )) == null ? void 0 : _a.width
    );
    return React.useEffect(() => {
      setStatus("idle");
    }, [JSON.stringify(src)]), React.useEffect(() => {
      onLoadingStatusChange(status), context.onImageLoadingStatusChange(status);
    }, [status]), <YStack fullscreen zIndex={1}><Image
      fullscreen
      {...typeof shapeSize == "number" && !isNaN(shapeSize) && {
        width: shapeSize,
        height: shapeSize
      }}
      {...imageProps}
      ref={forwardedRef}
      src={src}
      onError={() => {
        setStatus("error");
      }}
      onLoad={() => {
        setStatus("loaded");
      }}
    /></YStack>;
  }
);
AvatarImage.displayName = IMAGE_NAME;
const FALLBACK_NAME = "AvatarFallback", AvatarFallbackFrame = styled(YStack, {
  name: FALLBACK_NAME,
  position: "absolute",
  fullscreen: !0,
  zIndex: 0
}), AvatarFallback = AvatarFallbackFrame.extractable(
  React.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, delayMs, ...fallbackProps } = props, context = useAvatarContext(FALLBACK_NAME, __scopeAvatar), [canRender, setCanRender] = React.useState(delayMs === void 0);
      return React.useEffect(() => {
        if (delayMs !== void 0) {
          const timerId = setTimeout(() => setCanRender(!0), delayMs);
          return () => clearTimeout(timerId);
        }
      }, [delayMs]), canRender && context.imageLoadingStatus !== "loaded" ? <AvatarFallbackFrame {...fallbackProps} ref={forwardedRef} /> : null;
    }
  )
);
AvatarFallback.displayName = FALLBACK_NAME;
const AvatarFrame = styled(Square, {
  name: AVATAR_NAME,
  position: "relative",
  overflow: "hidden"
}), Avatar = withStaticProperties(
  React.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, size = "$true", ...avatarProps } = props, [imageLoadingStatus, setImageLoadingStatus] = React.useState("idle");
      return <AvatarProvider
        size={size}
        scope={__scopeAvatar}
        imageLoadingStatus={imageLoadingStatus}
        onImageLoadingStatusChange={setImageLoadingStatus}
      ><AvatarFrame size={size} {...avatarProps} ref={forwardedRef} /></AvatarProvider>;
    }
  ),
  {
    Image: AvatarImage,
    Fallback: AvatarFallback
  }
);
Avatar.displayName = AVATAR_NAME;
export {
  Avatar,
  AvatarFallback,
  AvatarFallbackFrame,
  AvatarFrame,
  AvatarImage,
  createAvatarScope
};
//# sourceMappingURL=Avatar.js.map
