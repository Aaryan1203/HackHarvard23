import { useComposedRefs } from "@tamagui/compose-refs";
import {
  Slottable,
  View,
  composeEventHandlers,
  isTamaguiElement,
  isWeb,
  styled,
  useIsomorphicLayoutEffect,
  withStaticProperties
} from "@tamagui/core";
import { createContextScope } from "@tamagui/create-context";
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogOverlay,
  DialogOverlayFrame,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
  DialogWarningProvider,
  createDialogScope
} from "@tamagui/dialog";
import { useControllableState } from "@tamagui/use-controllable-state";
import * as React from "react";
import { Alert } from "react-native";
const ROOT_NAME = "AlertDialog", [createAlertDialogContext, createAlertDialogScope] = createContextScope(ROOT_NAME, [
  createDialogScope
]), useDialogScope = createDialogScope(), TRIGGER_NAME = "AlertDialogTrigger", NativeAlertDialogTriggerFrame = styled(View, {
  name: TRIGGER_NAME
}), AlertDialogTrigger = React.forwardRef(
  (props, forwardedRef) => {
    if (props.__native) {
      const { __native, onPress, __onPress, ...rest } = props;
      return <NativeAlertDialogTriggerFrame
        {...rest}
        onPress={composeEventHandlers(onPress, __onPress)}
      />;
    }
    const { __scopeAlertDialog, ...triggerProps } = props, dialogScope = useDialogScope(__scopeAlertDialog);
    return <DialogTrigger {...dialogScope} {...triggerProps} ref={forwardedRef} />;
  }
);
AlertDialogTrigger.displayName = TRIGGER_NAME;
const PORTAL_NAME = "AlertDialogPortal", AlertDialogPortal = (props) => {
  const { __scopeAlertDialog, ...portalProps } = props, dialogScope = useDialogScope(__scopeAlertDialog);
  return <DialogPortal {...dialogScope} {...portalProps} />;
};
AlertDialogPortal.displayName = PORTAL_NAME;
const OVERLAY_NAME = "AlertDialogOverlay", AlertDialogOverlayFrame = styled(DialogOverlayFrame, {
  name: OVERLAY_NAME
}), AlertDialogOverlay = AlertDialogOverlayFrame.extractable(
  React.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAlertDialog, ...overlayProps } = props, dialogScope = useDialogScope(__scopeAlertDialog);
      return <DialogOverlay {...dialogScope} {...overlayProps} ref={forwardedRef} />;
    }
  )
);
AlertDialogOverlay.displayName = OVERLAY_NAME;
const CONTENT_NAME = "AlertDialogContent", [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME), AlertDialogContent = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, children, ...contentProps } = props, dialogScope = useDialogScope(__scopeAlertDialog), contentRef = React.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), cancelRef = React.useRef(null);
    return <DialogWarningProvider
      contentName={CONTENT_NAME}
      titleName={TITLE_NAME}
      docsSlug="alert-dialog"
    ><AlertDialogContentProvider scope={__scopeAlertDialog} cancelRef={cancelRef}><DialogContent
      role="alertdialog"
      {...dialogScope}
      {...contentProps}
      ref={composedRefs}
      onOpenAutoFocus={composeEventHandlers(
        contentProps.onOpenAutoFocus,
        (event) => {
          var _a;
          event.preventDefault(), isWeb && ((_a = cancelRef.current) == null || _a.focus({ preventScroll: !0 }));
        }
      )}
      onPointerDownOutside={(event) => event.preventDefault()}
      onInteractOutside={(event) => event.preventDefault()}
    >
      {
        /**
        * We have to use `Slottable` here as we cannot wrap the `AlertDialogContentProvider`
        * around everything, otherwise the `DescriptionWarning` would be rendered straight away.
        * This is because we want the accessibility checks to run only once the content is actually
        * open and that behaviour is already encapsulated in `DialogContent`.
        */
      }
      <Slottable>{children}</Slottable>
      {process.env.NODE_ENV === "development" && <DescriptionWarning contentRef={contentRef} />}
    </DialogContent></AlertDialogContentProvider></DialogWarningProvider>;
  }
);
AlertDialogContent.displayName = CONTENT_NAME;
const TITLE_NAME = "AlertDialogTitle", AlertDialogTitle = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...titleProps } = props, dialogScope = useDialogScope(__scopeAlertDialog);
    return <DialogTitle {...dialogScope} {...titleProps} ref={forwardedRef} />;
  }
);
AlertDialogTitle.displayName = TITLE_NAME;
const DESCRIPTION_NAME = "AlertDialogDescription", AlertDialogDescription = React.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...descriptionProps } = props, dialogScope = useDialogScope(__scopeAlertDialog);
  return <DialogDescription {...dialogScope} {...descriptionProps} ref={forwardedRef} />;
});
AlertDialogDescription.displayName = DESCRIPTION_NAME;
const ACTION_NAME = "AlertDialogAction", AlertDialogAction = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...actionProps } = props, dialogScope = useDialogScope(__scopeAlertDialog);
    return <DialogClose {...dialogScope} {...actionProps} ref={forwardedRef} />;
  }
);
AlertDialogAction.displayName = ACTION_NAME;
const CANCEL_NAME = "AlertDialogCancel", AlertDialogCancel = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...cancelProps } = props, { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog), dialogScope = useDialogScope(__scopeAlertDialog), ref = useComposedRefs(forwardedRef, cancelRef);
    return <DialogClose {...dialogScope} {...cancelProps} ref={ref} />;
  }
);
AlertDialogCancel.displayName = CANCEL_NAME;
const DescriptionWarning = ({ contentRef }) => (process.env.NODE_ENV === "development" && React.useEffect(() => {
  var _a;
  if (!isWeb)
    return;
  document.getElementById(
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
    (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby")
  ) || console.warn(`\`${CONTENT_NAME}\` requires a description for the component to be accessible for screen reader users.
  
        You can add a description to the \`${CONTENT_NAME}\` by passing a \`${DESCRIPTION_NAME}\` component as a child, which also benefits sighted users by adding visible context to the dialog.
        
        Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.
        
        For more information, see https://tamagui.dev/docs/components/alert-dialog`);
}, [contentRef]), null), AlertDialogInner = (props) => {
  const { __scopeAlertDialog, native, ...alertDialogProps } = props, dialogScope = useDialogScope(__scopeAlertDialog);
  {
    const [open, setOpen] = useControllableState({
      prop: props.open,
      defaultProp: props.defaultOpen || !1,
      onChange: props.onOpenChange,
      transition: !0
    });
    let triggerElement = null, title = "", description = "";
    const buttons = [];
    if (forEachChildDeep(React.Children.toArray(props.children), (child) => {
      if (!React.isValidElement(child))
        return !1;
      const name = isTamaguiElement(child) ? child.type.staticConfig.componentName : child.type.displayName;
      switch (name) {
        case TRIGGER_NAME:
          return triggerElement = React.cloneElement(child, {
            __native: !0
          }), !1;
        case TITLE_NAME:
          return title = getStringChildren(child), !1;
        case DESCRIPTION_NAME:
          return description = getStringChildren(child), !1;
        case ACTION_NAME:
        case CANCEL_NAME: {
          const style = name === ACTION_NAME ? "default" : "cancel", text = getStringChildren(child), onPress = () => {
            var _a;
            const childProps = child.props;
            (_a = childProps == null ? void 0 : childProps.onPress) == null || _a.call(childProps, { native: !0 }), setOpen(!1);
          };
          return buttons.push({
            style,
            text,
            // @ts-ignore
            onPress
          }), !1;
        }
        default:
          return !0;
      }
    }), useIsomorphicLayoutEffect(() => {
      !open || !native || (title || description) && Alert.alert(title, description, buttons);
    }, [native, open]), native)
      return React.cloneElement(triggerElement, {
        __onPress: () => {
          setOpen(!0);
        }
      });
  }
  return <Dialog {...dialogScope} {...alertDialogProps} modal />;
};
function forEachChildDeep(children, onChild) {
  for (const child of children)
    React.isValidElement(child) && onChild(child) && child.props.children && forEachChildDeep(React.Children.toArray(child.props.children), onChild);
}
function getStringChildren(child) {
  let string = "";
  return forEachChildDeep(React.Children.toArray(child), (child2) => typeof child2.props.children == "string" ? (string = child2.props.children, !1) : !0), string;
}
const AlertDialog = withStaticProperties(AlertDialogInner, {
  Trigger: AlertDialogTrigger,
  Portal: AlertDialogPortal,
  Overlay: AlertDialogOverlay,
  Content: AlertDialogContent,
  Action: AlertDialogAction,
  Cancel: AlertDialogCancel,
  Title: AlertDialogTitle,
  Description: AlertDialogDescription
});
AlertDialog.displayName = ROOT_NAME;
export {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogOverlay,
  AlertDialogPortal,
  AlertDialogTitle,
  AlertDialogTrigger,
  createAlertDialogScope
};
//# sourceMappingURL=AlertDialog.js.map
