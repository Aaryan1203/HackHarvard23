import { useComposedRefs } from "@tamagui/compose-refs";
import {
  composeEventHandlers,
  isWeb,
  useProps,
  withStaticProperties
} from "@tamagui/core";
import { registerFocusable } from "@tamagui/focusable";
import { useLabelContext } from "@tamagui/label";
import { YStack } from "@tamagui/stacks";
import { useControllableState } from "@tamagui/use-controllable-state";
import { usePrevious } from "@tamagui/use-previous";
import * as React from "react";
import {
  Switch as NativeSwitch,
  Platform
} from "react-native";
import { SwitchFrame as DefaultSwitchFrame, SwitchThumb } from "./Switch";
import { SwitchContext } from "./SwitchContext";
function createSwitch({
  disableActiveTheme,
  Frame = DefaultSwitchFrame,
  Thumb = SwitchThumb
}) {
  process.env.NODE_ENV === "development" && (Frame !== DefaultSwitchFrame && Frame.staticConfig.context && console.warn(
    "Warning: createSwitch() needs to control context to pass checked state from Frame to Thumb, any custom context passed will be overridden."
  ), Thumb !== SwitchThumb && Thumb.staticConfig.context && console.warn(
    "Warning: createSwitch() needs to control context to pass checked state from Frame to Thumb, any custom context passed will be overridden."
  )), Frame.staticConfig.context = SwitchContext, Thumb.staticConfig.context = SwitchContext;
  const SwitchThumbComponent = Thumb.styleable(function(props, forwardedRef) {
    const { size: sizeProp, unstyled: unstyledProp, ...thumbProps } = props, context = React.useContext(SwitchContext), {
      disabled,
      checked,
      unstyled: unstyledContext,
      frameWidth,
      size: sizeContext
    } = context, [thumbWidth, setThumbWidth] = React.useState(0), initialChecked = React.useRef(checked).current, distance = frameWidth - thumbWidth, x = initialChecked ? checked ? 0 : -distance : checked ? distance : 0, unstyled = unstyledProp ?? unstyledContext ?? !1;
    return (
      // @ts-ignore
      <Thumb
        {...unstyled === !1 && {
          unstyled: !1,
          size: sizeProp ?? sizeContext ?? "$true",
          ...!disableActiveTheme && {
            theme: checked ? "active" : null
          }
        }}
        data-state={getState(checked)}
        data-disabled={disabled ? "" : void 0}
        alignSelf={initialChecked ? "flex-end" : "flex-start"}
        checked={checked}
        x={x}
        {...thumbProps}
        onLayout={composeEventHandlers(
          props.onLayout,
          (e) => (
            // @ts-ignore
            setThumbWidth(e.nativeEvent.layout.width)
          )
        )}
        ref={forwardedRef}
      />
    );
  }), SwitchComponent = Frame.extractable(
    React.forwardRef(function(propsIn, forwardedRef) {
      const styledContext = React.useContext(SwitchContext), props = useProps(propsIn, {
        noNormalize: !0,
        noExpand: !0,
        resolveValues: "none",
        forComponent: Frame
      }), {
        labeledBy: ariaLabelledby,
        name,
        checked: checkedProp,
        defaultChecked,
        required,
        disabled,
        value = "on",
        onCheckedChange,
        size = styledContext.size ?? "$true",
        unstyled = styledContext.unstyled ?? !1,
        native: nativeProp,
        nativeProps,
        children,
        ...switchProps
      } = props, native = Array.isArray(nativeProp) ? nativeProp : [nativeProp], shouldRenderMobileNative = !isWeb && nativeProp === !0 || !isWeb && native.includes("mobile") || native.includes("android") && Platform.OS === "android" || native.includes("ios") && Platform.OS === "ios", [button, setButton] = React.useState(null), composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node)), labelId = useLabelContext(button), labelledBy = ariaLabelledby || labelId, hasConsumerStoppedPropagationRef = React.useRef(!1), isFormControl = isWeb ? button ? !!button.closest("form") : !0 : !1, [frameWidth, setFrameWidth] = React.useState(0), [checked = !1, setChecked] = useControllableState({
        prop: checkedProp,
        defaultProp: defaultChecked || !1,
        onChange: onCheckedChange,
        transition: !0
      });
      return shouldRenderMobileNative ? <NativeSwitch
        value={checkedProp}
        onValueChange={onCheckedChange}
        {...nativeProps}
      /> : (isWeb || React.useEffect(() => {
        if (props.id)
          return registerFocusable(props.id, {
            focus: () => {
              setChecked((x) => !x);
            }
          });
      }, [props.id, setChecked]), <>
        {
          /* @ts-ignore */
        }
        <Frame
          unstyled={unstyled}
          size={size}
          checked={checked}
          disabled={disabled}
          frameWidth={frameWidth}
          themeShallow
          {...!disableActiveTheme && {
            theme: checked ? "active" : null,
            themeShallow: !0
          }}
          role="switch"
          aria-checked={checked}
          aria-labelledby={labelledBy}
          aria-required={required}
          data-state={getState(checked)}
          data-disabled={disabled ? "" : void 0}
          tabIndex={disabled ? void 0 : 0}
          value={value}
          {...switchProps}
          ref={composedRefs}
          onPress={composeEventHandlers(props.onPress, (event) => {
            setChecked((prevChecked) => !prevChecked), isWeb && isFormControl && (hasConsumerStoppedPropagationRef.current = event.isPropagationStopped(), hasConsumerStoppedPropagationRef.current || event.stopPropagation());
          })}
        ><YStack
          alignSelf="stretch"
          flex={1}
          onLayout={(e) => {
            setFrameWidth(e.nativeEvent.layout.width);
          }}
        >{typeof children == "function" ? children(checked) : children}</YStack></Frame>
        {isWeb && isFormControl && <BubbleInput
          control={button}
          bubbles={!hasConsumerStoppedPropagationRef.current}
          name={name}
          value={value}
          checked={checked}
          required={required}
          disabled={disabled}
          style={{ transform: "translateX(-100%)" }}
        />}
      </>);
    })
  ), BubbleInput = (props) => {
    const { control, checked, bubbles = !0, ...inputProps } = props, ref = React.useRef(null), prevChecked = usePrevious(checked);
    return React.useEffect(() => {
      const input = ref.current, inputProto = window.HTMLInputElement.prototype, setChecked = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      ).set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked), input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]), // @ts-ignore
    <input
      type="checkbox"
      aria-hidden
      defaultChecked={checked}
      {...inputProps}
      tabIndex={-1}
      ref={ref}
      style={{
        ...props.style,
        // ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }}
    />;
  };
  function getState(checked) {
    return checked ? "checked" : "unchecked";
  }
  return withStaticProperties(SwitchComponent, {
    Thumb: SwitchThumbComponent
  });
}
export {
  createSwitch
};
//# sourceMappingURL=createSwitch.js.map
