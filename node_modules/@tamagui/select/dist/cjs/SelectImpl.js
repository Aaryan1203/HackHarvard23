var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var SelectImpl_exports = {};
__export(SelectImpl_exports, {
  SelectInlineImpl: () => SelectInlineImpl
});
module.exports = __toCommonJS(SelectImpl_exports);
var import_react = require("@floating-ui/react"), import_core = require("@tamagui/core"), React = __toESM(require("react")), import_react_dom = require("react-dom"), import_constants = require("./constants"), import_context = require("./context"), import_jsx_runtime = require("react/jsx-runtime");
const SelectInlineImpl = (props) => {
  const {
    __scopeSelect,
    children,
    open = !1,
    selectedIndexRef,
    listContentRef
  } = props, selectContext = (0, import_context.useSelectContext)("SelectSheetImpl", __scopeSelect), selectItemParentContext = (0, import_context.useSelectItemParentContext)(
    "SelectSheetImpl",
    __scopeSelect
  ), { setActiveIndex, selectedIndex, activeIndex, forceUpdate } = selectContext, { setOpen, setSelectedIndex } = selectItemParentContext, [scrollTop, setScrollTop] = React.useState(0), touch = (0, import_core.useIsTouchDevice)(), listItemsRef = React.useRef([]), overflowRef = React.useRef(null), upArrowRef = React.useRef(null), downArrowRef = React.useRef(null), allowSelectRef = React.useRef(!1), allowMouseUpRef = React.useRef(!0), selectTimeoutRef = React.useRef(), state = React.useRef({
    isMouseOutside: !1
  }), [controlledScrolling, setControlledScrolling] = React.useState(!1), [fallback, setFallback] = React.useState(!1), [innerOffset, setInnerOffset] = React.useState(0), [blockSelection, setBlockSelection] = React.useState(!1), floatingStyle = React.useRef({});
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    queueMicrotask(() => {
      open || (setScrollTop(0), setFallback(!1), setActiveIndex(null), setControlledScrolling(!1));
    });
  }, [open, setActiveIndex]), import_core.isWeb && import_core.isClient && (0, import_core.useIsomorphicLayoutEffect)(() => {
    if (!open)
      return;
    const mouseUp = (e) => {
      state.current.isMouseOutside && setOpen(!1);
    };
    return document.addEventListener("mouseup", mouseUp), () => {
      document.removeEventListener("mouseup", mouseUp);
    };
  }, [open]);
  const flipOrShiftMiddlewares = [
    touch ? (0, import_react.shift)({ crossAxis: !0, padding: import_constants.WINDOW_PADDING }) : (0, import_react.flip)({ padding: import_constants.WINDOW_PADDING })
  ], { x, y, strategy, context, refs, update } = (0, import_react.useFloating)({
    open,
    onOpenChange: setOpen,
    placement: "bottom-start",
    middleware: [
      (0, import_react.size)({
        apply({
          rects: {
            reference: { width }
          }
        }) {
          floatingStyle.current = {
            minWidth: width + 8
          };
        }
      }),
      ...flipOrShiftMiddlewares,
      (0, import_react.inner)({
        listRef: listItemsRef,
        overflowRef,
        index: selectedIndex,
        offset: innerOffset,
        // onFallbackChange: setFallback,
        padding: 10,
        minItemsVisible: touch ? 10 : 4,
        referenceOverflowThreshold: 20
      }),
      (0, import_react.offset)({ crossAxis: -5 })
    ]
  });
  (0, import_core.useIsomorphicLayoutEffect)(() => (window.addEventListener("resize", update), open && update(), () => window.removeEventListener("resize", update)), [update, open]);
  const floatingRef = refs.floating, showUpArrow = open && scrollTop > import_constants.SCROLL_ARROW_THRESHOLD, showDownArrow = open && floatingRef.current && scrollTop < floatingRef.current.scrollHeight - floatingRef.current.clientHeight - import_constants.SCROLL_ARROW_THRESHOLD, onMatch = (0, import_core.useEvent)((index) => (open ? setActiveIndex : setSelectedIndex)(index)), interactionsProps = [
    (0, import_react.useClick)(context, { event: "mousedown" }),
    (0, import_react.useDismiss)(context, { outsidePress: !1 }),
    (0, import_react.useRole)(context, { role: "listbox" }),
    (0, import_react.useInnerOffset)(context, {
      enabled: !fallback,
      onChange: setInnerOffset,
      overflowRef,
      scrollRef: refs.floating
    }),
    (0, import_react.useListNavigation)(context, {
      listRef: listItemsRef,
      activeIndex: activeIndex || 0,
      selectedIndex,
      onNavigate: setActiveIndex
    }),
    (0, import_react.useTypeahead)(context, {
      listRef: listContentRef,
      onMatch,
      selectedIndex,
      activeIndex
    })
  ], interactions = (0, import_react.useInteractions)(
    // unfortunately these memos will just always break due to floating-ui context always changing :/
    React.useMemo(() => interactionsProps, interactionsProps)
  ), interactionsContext = React.useMemo(() => ({
    ...interactions,
    getReferenceProps() {
      return interactions.getReferenceProps({
        ref: refs.reference,
        className: "SelectTrigger",
        onKeyDown(event) {
          (event.key === "Enter" || event.key === " " && !context.dataRef.current.typing) && (event.preventDefault(), setOpen(!0));
        }
      });
    },
    getFloatingProps(props2) {
      return interactions.getFloatingProps({
        ref: refs.floating,
        className: "Select",
        ...props2,
        style: {
          position: strategy,
          top: y ?? "",
          left: x ?? "",
          outline: 0,
          scrollbarWidth: "none",
          ...floatingStyle.current,
          ...props2 == null ? void 0 : props2.style
        },
        onPointerEnter() {
          setControlledScrolling(!1), state.current.isMouseOutside = !1;
        },
        onPointerLeave() {
          state.current.isMouseOutside = !0;
        },
        onPointerMove() {
          state.current.isMouseOutside = !1, setControlledScrolling(!1);
        },
        onKeyDown() {
          setControlledScrolling(!0);
        },
        onContextMenu(e) {
          e.preventDefault();
        },
        onScroll(event) {
          (0, import_react_dom.flushSync)(() => setScrollTop(event.currentTarget.scrollTop));
        }
      });
    }
  }), [refs.reference.current, x, y, refs.floating.current, interactions]);
  return (0, import_core.useIsomorphicLayoutEffect)(() => {
    if (open)
      return selectTimeoutRef.current = setTimeout(() => {
        allowSelectRef.current = !0;
      }, 300), () => {
        clearTimeout(selectTimeoutRef.current);
      };
    allowSelectRef.current = !1, allowMouseUpRef.current = !0, setInnerOffset(0), setFallback(!1), setBlockSelection(!1);
  }, [open]), (0, import_core.useIsomorphicLayoutEffect)(() => {
    !open && state.current.isMouseOutside && (state.current.isMouseOutside = !1);
  }, [open]), (0, import_core.useIsomorphicLayoutEffect)(() => {
    function onPointerDown(e) {
      var _a, _b, _c;
      const target = e.target;
      (_a = refs.floating.current) != null && _a.contains(target) || (_b = upArrowRef.current) != null && _b.contains(target) || (_c = downArrowRef.current) != null && _c.contains(target) || (setOpen(!1), setControlledScrolling(!1));
    }
    if (open)
      return document.addEventListener("pointerdown", onPointerDown), () => {
        document.removeEventListener("pointerdown", onPointerDown);
      };
  }, [open, refs, setOpen]), React.useEffect(() => {
    var _a, _b;
    open && controlledScrolling && activeIndex != null && ((_a = listItemsRef.current[activeIndex]) == null || _a.scrollIntoView({ block: "nearest" })), setScrollTop(((_b = refs.floating.current) == null ? void 0 : _b.scrollTop) ?? 0);
  }, [open, refs, controlledScrolling, activeIndex]), React.useEffect(() => {
    var _a;
    open && fallback && selectedIndex != null && ((_a = listItemsRef.current[selectedIndex]) == null || _a.scrollIntoView({ block: "nearest" }));
  }, [open, fallback, selectedIndex]), (0, import_core.useIsomorphicLayoutEffect)(() => {
    refs.floating.current && fallback && (refs.floating.current.style.maxHeight = "");
  }, [refs, fallback]), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_context.SelectProvider,
    {
      scope: __scopeSelect,
      ...selectContext,
      setScrollTop,
      setInnerOffset,
      fallback,
      floatingContext: context,
      activeIndex,
      canScrollDown: !!showDownArrow,
      canScrollUp: !!showUpArrow,
      controlledScrolling,
      blockSelection,
      upArrowRef,
      downArrowRef,
      update,
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_context.SelectItemParentProvider,
        {
          scope: __scopeSelect,
          ...selectItemParentContext,
          allowMouseUpRef,
          allowSelectRef,
          dataRef: context.dataRef,
          interactions: interactionsContext,
          listRef: listItemsRef,
          selectTimeoutRef,
          children
        }
      )
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SelectInlineImpl
});
//# sourceMappingURL=SelectImpl.js.map
