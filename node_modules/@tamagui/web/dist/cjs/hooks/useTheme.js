var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var useTheme_exports = {};
__export(useTheme_exports, {
  activeThemeManagers: () => activeThemeManagers,
  getThemeProxied: () => getThemeProxied,
  useChangeThemeEffect: () => useChangeThemeEffect,
  useTheme: () => useTheme,
  useThemeWithState: () => useThemeWithState
});
module.exports = __toCommonJS(useTheme_exports);
var import_constants = require("@tamagui/constants"), import_react = require("react"), import_config = require("../config"), import_createVariable = require("../createVariable"), import_createProxy = require("../helpers/createProxy"), import_createShallowSetState = require("../helpers/createShallowSetState"), import_ThemeManager = require("../helpers/ThemeManager"), import_ThemeManagerContext = require("../helpers/ThemeManagerContext"), import_getThemeUnwrapped = require("./getThemeUnwrapped");
const emptyProps = { name: null };
let cached;
function getDefaultThemeProxied() {
  if (cached)
    return cached;
  const config = (0, import_config.getConfig)(), name = config.themes.light ? "light" : Object.keys(config.themes)[0], defaultTheme = config.themes[name];
  return cached = getThemeProxied({ theme: defaultTheme, name }), cached;
}
const useTheme = (props = emptyProps) => {
  const [_, theme] = useThemeWithState(props);
  return theme || getDefaultThemeProxied();
}, useThemeWithState = (props) => {
  const keys = (0, import_react.useRef)([]), changedThemeState = useChangeThemeEffect(
    props,
    !1,
    keys.current,
    import_constants.isServer ? void 0 : () => {
      var _a, _b;
      const next = ((_a = props.shouldUpdate) == null ? void 0 : _a.call(props)) ?? (keys.current.length > 0 ? !0 : void 0);
      return process.env.NODE_ENV === "development" && props.debug && props.debug !== "profile" && console.info("  \u{1F3A8} useTheme() shouldUpdate?", next, {
        shouldUpdateProp: (_b = props.shouldUpdate) == null ? void 0 : _b.call(props),
        keys: [...keys.current]
      }), next;
    }
  ), { themeManager, state } = changedThemeState;
  state != null && state.theme || process.env.NODE_ENV === "development" && process.env.TAMAGUI_DISABLE_NO_THEME_WARNING !== "1" && console.warn(
    `[tamagui] No theme found, this could be due to an invalid theme name (given theme props ${JSON.stringify(
      props
    )}).

If this is intended and you are using Tamagui without any themes, you can disable this warning by setting the environment variable TAMAGUI_DISABLE_NO_THEME_WARNING=1`
  );
  const themeProxied = (0, import_react.useMemo)(() => !themeManager || !(state != null && state.theme) ? {} : getThemeProxied(state, props.deopt, themeManager, keys.current, props.debug), [state, themeManager, props.deopt, props.debug]);
  return process.env.NODE_ENV === "development" && props.debug === "verbose" && (console.groupCollapsed("  \u{1F539} useTheme =>", state == null ? void 0 : state.name), console.info("returning state", changedThemeState, "from props", props), console.groupEnd()), [changedThemeState, themeProxied];
};
function getThemeProxied({ theme, name, scheme }, deopt = !1, themeManager, keys, debug) {
  if (!theme)
    return {};
  const config = (0, import_config.getConfig)();
  function track(key) {
    keys && !keys.includes(key) && (keys.push(key), process.env.NODE_ENV === "development" && debug && console.info(` \u{1F3A8} useTheme() tracking new key: ${key}`));
  }
  return (0, import_createProxy.createProxy)(theme, {
    has(_, key) {
      if (Reflect.has(theme, key))
        return !0;
      if (typeof key == "string")
        return key[0] === "$" && (key = key.slice(1)), themeManager == null ? void 0 : themeManager.allKeys.has(key);
    },
    get(_, key) {
      if (key === import_getThemeUnwrapped.GetThemeUnwrapped)
        return theme;
      if (
        // dont ask me, idk why but on hermes you can see that useTheme()[undefined] passes in STRING undefined to proxy
        // if someone is crazy enough to use "undefined" as a theme key then this not working is on them
        key !== "undefined" && typeof key == "string"
      ) {
        const keyString = key[0] === "$" ? key.slice(1) : key, val = theme[keyString];
        if (val && typeof val == "object")
          return new Proxy(val, {
            // when they touch the actual value we only track it
            // if its a variable (web), its ignored!
            get(_2, subkey) {
              if (subkey === "val")
                track(keyString);
              else if (subkey === "get")
                return (platform) => (0, import_createVariable.getVariable)(val);
              return Reflect.get(val, subkey);
            }
          });
      }
      return Reflect.get(_, key);
    }
  });
}
const activeThemeManagers = /* @__PURE__ */ new Set(), useChangeThemeEffect = (props, isRoot = !1, keys, shouldUpdate) => {
  const { disable } = props, parentManager = (0, import_react.useContext)(import_ThemeManagerContext.ThemeManagerContext);
  if (!isRoot && !parentManager || disable)
    return {
      isNewTheme: !1,
      state: parentManager == null ? void 0 : parentManager.state,
      themeManager: parentManager
    };
  const [themeState, setThemeState] = (0, import_react.useState)(createState), { state, mounted, isNewTheme, themeManager, inversed } = themeState, isInversingOnMount = !!(!themeState.mounted && props.inverse);
  function getShouldUpdateTheme(manager = themeManager, nextState, prevState = state, forceShouldChange = !1) {
    const forceUpdate = shouldUpdate == null ? void 0 : shouldUpdate();
    if (!manager || !forceShouldChange && forceUpdate === !1)
      return;
    const next = nextState || manager.getState(props, parentManager);
    if (forceShouldChange)
      return next;
    if (next && !(forceUpdate !== !0 && !manager.getStateShouldChange(next, prevState)))
      return next;
  }
  if (import_constants.isServer || ((0, import_react.useLayoutEffect)(() => {
    if (!themeManager)
      return;
    if (props.inverse && !mounted) {
      setThemeState((prev) => createState({
        ...prev,
        mounted: !0
      }));
      return;
    }
    isNewTheme && themeManager && activeThemeManagers.add(themeManager), (isNewTheme || getShouldUpdateTheme(themeManager)) && setThemeState(createState);
    const selfListenerDispose = themeManager.onChangeTheme((_a, _b, forced) => {
      forced && setThemeState((prev) => createState(prev, !0));
    }), disposeChangeListener = parentManager == null ? void 0 : parentManager.onChangeTheme((name, manager) => {
      const force = (shouldUpdate == null ? void 0 : shouldUpdate()) || props.deopt || void 0, shouldTryUpdate = force ?? !!(keys != null && keys.length || isNewTheme);
      process.env.NODE_ENV === "development" && props.debug && console.info(" \u{1F538} onChange", themeManager.id, {
        force,
        shouldTryUpdate,
        props,
        name,
        manager,
        keys
      }), shouldTryUpdate && setThemeState(createState);
    }, themeManager.id);
    return () => {
      selfListenerDispose(), disposeChangeListener == null || disposeChangeListener(), activeThemeManagers.delete(themeManager);
    };
  }, [
    themeManager,
    parentManager,
    isNewTheme,
    props.componentName,
    props.inverse,
    props.name,
    props.reset,
    mounted
  ]), process.env.NODE_ENV === "development" && props.debug !== "profile" && (0, import_react.useEffect)(() => (globalThis.TamaguiThemeManagers ??= /* @__PURE__ */ new Set(), globalThis.TamaguiThemeManagers.add(themeManager), () => {
    globalThis.TamaguiThemeManagers.delete(themeManager);
  }), [themeManager])), isInversingOnMount)
    return {
      isNewTheme: !1,
      inversed: !1,
      themeManager: parentManager,
      state: {
        name: "",
        ...parentManager == null ? void 0 : parentManager.state,
        className: ""
      }
    };
  return {
    state,
    isNewTheme,
    inversed,
    themeManager
  };
  function createState(prev, force = !1) {
    if (prev && (shouldUpdate == null ? void 0 : shouldUpdate()) === !1)
      return prev;
    let themeManager2 = parentManager, state2;
    if ((0, import_ThemeManager.getHasThemeUpdatingProps)(props)) {
      const getNewThemeManager = () => new import_ThemeManager.ThemeManager(props, isRoot ? "root" : parentManager);
      if (prev != null && prev.themeManager) {
        themeManager2 = prev.themeManager;
        const forceChange = !!(keys != null && keys.length), next = themeManager2.getState(props, parentManager), nextState = getShouldUpdateTheme(
          themeManager2,
          next,
          prev.state,
          forceChange
        );
        nextState ? (state2 = nextState, prev.isNewTheme ? themeManager2.updateState(nextState) : themeManager2 = getNewThemeManager()) : prev.isNewTheme && parentManager && !next && (themeManager2 = parentManager);
      } else
        themeManager2 = getNewThemeManager(), state2 = { ...themeManager2.state };
    }
    const isNewTheme2 = !!(themeManager2 !== parentManager || props.inverse), mounted2 = props.inverse ? isRoot || (prev == null ? void 0 : prev.mounted) : !0;
    state2 || (isNewTheme2 ? state2 = themeManager2.state : (state2 = parentManager.state, themeManager2 = parentManager));
    const wasInversed = prev == null ? void 0 : prev.inversed, inversed2 = isNewTheme2 && state2.scheme !== (parentManager == null ? void 0 : parentManager.state.scheme) ? !0 : wasInversed ? !1 : null, response = {
      themeManager: themeManager2,
      isNewTheme: isNewTheme2,
      mounted: mounted2,
      inversed: inversed2
    }, shouldReturnPrev = !force && prev && // isEqualShallow uses the second arg as the keys so this should compare without state first...
    (0, import_createShallowSetState.isEqualShallow)(prev, response) && // ... and then compare just the state, because we make a new state obj but is likely the same
    (0, import_createShallowSetState.isEqualShallow)(prev.state, state2);
    if (prev && shouldReturnPrev)
      return prev;
    if (response.state = state2, process.env.NODE_ENV === "development" && props.debug && import_constants.isClient) {
      console.groupCollapsed(` \u{1F537} ${themeManager2.id} useChangeThemeEffect createState`);
      const parentState = { ...parentManager == null ? void 0 : parentManager.state }, parentId = parentManager == null ? void 0 : parentManager.id, themeManagerState = { ...themeManager2.state };
      console.info({
        props,
        parentState,
        parentId,
        themeManager: themeManager2,
        prev,
        response,
        themeManagerState
      }), console.groupEnd();
    }
    return response;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activeThemeManagers,
  getThemeProxied,
  useChangeThemeEffect,
  useTheme,
  useThemeWithState
});
//# sourceMappingURL=useTheme.js.map
