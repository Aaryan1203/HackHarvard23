var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var ThemeManager_exports = {};
__export(ThemeManager_exports, {
  ThemeManager: () => ThemeManager,
  getHasThemeUpdatingProps: () => getHasThemeUpdatingProps,
  getManagers: () => getManagers
});
module.exports = __toCommonJS(ThemeManager_exports);
var import_constants = require("@tamagui/constants"), import_config = require("../config"), import_constants2 = require("../constants/constants");
const emptyState = { name: "" };
function getHasThemeUpdatingProps(props) {
  return props.name || props.componentName || props.inverse || props.reset;
}
let uid = 0;
class ThemeManager {
  constructor(props = {}, parentManager) {
    this.props = props;
    if (parentManager === "root") {
      this.updateStateFromProps(props, !1);
      return;
    }
    if (!parentManager)
      throw process.env.NODE_ENV !== "production" ? new Error(
        "No parent manager given, this is likely due to duplicated Tamagui dependencies. Check your lockfile for mis-matched versions. It could also be from an error somewhere else in your stack causing Tamagui to recieve undefined context, you can try putting some ErrorBoundary components around other areas of your app, or a Suspense boundary."
      ) : "\u274C 0";
    if (this.parentManager = parentManager, !this.updateStateFromProps(props, !1))
      return parentManager;
  }
  id = uid++;
  themeListeners = /* @__PURE__ */ new Set();
  parentManager = null;
  state = emptyState;
  updateStateFromProps(props = this.props || {}, shouldNotify = !0) {
    if (this.props = props, props.forceTheme)
      return this.state.theme = props.forceTheme, this.state.name = props.name || "", !0;
    const nextState = this.getStateIfChanged(props);
    if (nextState)
      return this.updateState(nextState, shouldNotify), nextState;
  }
  updateState(nextState, shouldNotify = !0) {
    this.state = nextState, this._allKeys = null, process.env.NODE_ENV !== "production" && (this._numChangeEventsSent ??= 0, this._numChangeEventsSent++), shouldNotify && queueMicrotask(() => {
      this.notify();
    });
  }
  getStateIfChanged(props = this.props, state = this.state, parentManager = this.parentManager) {
    const _ = this.getState(props, parentManager);
    if (state && state !== emptyState && !_)
      return parentManager == null ? void 0 : parentManager.state;
    if (this.getStateShouldChange(_, state))
      return _;
  }
  getStateShouldChange(nextState, state = this.state) {
    return !(!(nextState != null && nextState.theme) || nextState.theme === (state == null ? void 0 : state.theme));
  }
  getState(props = this.props, parentManager = this.parentManager) {
    return getState(props, parentManager) || null;
  }
  _allKeys = null;
  get allKeys() {
    var _a;
    return this._allKeys ||= /* @__PURE__ */ new Set([
      ...((_a = this.parentManager) == null ? void 0 : _a.allKeys) || [],
      ...Object.keys(this.state.theme || {})
    ]), this._allKeys;
  }
  notify(forced = !1) {
    this.themeListeners.forEach((cb) => cb(this.state.name, this, forced));
  }
  onChangeTheme(cb, debugId) {
    return process.env.NODE_ENV !== "production" && debugId && (this._listeningIds ??= /* @__PURE__ */ new Set(), this._listeningIds.add(debugId)), this.themeListeners.add(cb), () => {
      this.themeListeners.delete(cb);
    };
  }
}
function getState(props, manager) {
  var _a;
  if (props.name && props.reset)
    throw new Error(
      process.env.NODE_ENV === "production" ? "\u274C004" : "Cannot reset and set a new name at the same time."
    );
  if (!getHasThemeUpdatingProps(props))
    return null;
  const themes = (0, import_config.getThemes)(), [allManagers, componentManagers] = getManagers(manager), isDirectParentAComponentTheme = !!(manager != null && manager.state.isComponent), startIndex = props.reset && !isDirectParentAComponentTheme ? 1 : 0;
  let baseManager = allManagers[startIndex], parentManager = allManagers[startIndex + 1];
  if (!baseManager && props.reset)
    return process.env.NODE_ENV !== "production" && console.warn("Cannot reset, no parent theme exists"), null;
  const { componentName } = props;
  let result = null, baseName = (baseManager == null ? void 0 : baseManager.state.name) || "";
  baseManager != null && baseManager.state.isComponent && (baseName = baseName.replace(/_[A-Z][a-z]+/, ""));
  const nextName = props.reset ? baseName : props.name || "", allComponentThemes = componentManagers.map((x) => (x == null ? void 0 : x.state.name) || "");
  isDirectParentAComponentTheme && allComponentThemes.shift();
  const base = baseName.split(import_constants2.THEME_NAME_SEPARATOR), max = base.length, min = props.componentName && !nextName ? max : 0;
  process.env.NODE_ENV !== "production" && typeof props.debug == "string" && (console.groupCollapsed("ThemeManager.getState()"), console.info({ props, baseName, base, min, max }));
  for (let i = max; i >= min; i--) {
    let prefix = base.slice(0, i).join(import_constants2.THEME_NAME_SEPARATOR);
    props.inverse && (prefix = inverseThemeName(prefix));
    let potentials = [];
    if (prefix && prefix !== baseName && potentials.push(prefix), nextName && potentials.unshift(prefix ? `${prefix}_${nextName}` : nextName), i === 1) {
      const lastSegment = potentials.findIndex((x) => !x.includes("_"));
      lastSegment > 0 && potentials.splice(lastSegment, 0, nextName);
    }
    if (componentName && !props.reset) {
      let componentPotentials = [];
      if (nextName) {
        const beforeSeparator = prefix.slice(0, prefix.indexOf(import_constants2.THEME_NAME_SEPARATOR));
        componentPotentials.push(`${beforeSeparator}_${nextName}_${componentName}`);
      }
      if (componentPotentials.push(`${prefix}_${componentName}`), nextName) {
        const prefixLessOne = base.slice(0, i - 1).join(import_constants2.THEME_NAME_SEPARATOR);
        if (prefixLessOne) {
          const lessSpecific = `${prefixLessOne}_${nextName}_${componentName}`;
          componentPotentials.unshift(lessSpecific);
        }
        const moreSpecific = `${prefix}_${nextName}_${componentName}`;
        componentPotentials.unshift(moreSpecific);
      }
      potentials = [...componentPotentials, ...potentials, ...allComponentThemes];
    }
    const found = potentials.find((t) => t in themes);
    if (process.env.NODE_ENV !== "production" && typeof props.debug == "string" && console.info(" - ", { found, potentials, baseManager, nextName, baseName, prefix }), found) {
      const names = found.split("_"), [firstName, ...restNames] = names, lastName = names[names.length - 1], isComponent = lastName[0] === lastName[0].toUpperCase(), scheme = firstName === "light" ? "light" : firstName === "dark" ? "dark" : void 0, pre = import_constants2.THEME_CLASSNAME_PREFIX, className = import_constants.isWeb ? `${pre}sub_theme ${pre}${!scheme || !restNames.length ? firstName : restNames.join("_")}` : "", parentState = (_a = baseManager || parentManager) == null ? void 0 : _a.state, parentName = parentState == null ? void 0 : parentState.name;
      result = {
        name: found,
        parentName,
        theme: themes[found],
        className,
        isComponent,
        scheme
      };
      break;
    }
  }
  return process.env.NODE_ENV !== "production" && typeof props.debug == "string" && typeof window < "u" && (console.warn("ThemeManager.getState():", { result }), console.trace(), console.groupEnd()), result;
}
const inverseThemeName = (themeName) => themeName.startsWith("light") ? themeName.replace(/^light/, "dark") : themeName.replace(/^dark/, "light");
function getManagers(themeManager) {
  const comp = [], all = [];
  let cur = themeManager;
  for (; cur; )
    all.push(cur), cur.state.isComponent && comp.push(cur), cur = cur.parentManager;
  return [all, comp];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ThemeManager,
  getHasThemeUpdatingProps,
  getManagers
});
//# sourceMappingURL=ThemeManager.js.map
