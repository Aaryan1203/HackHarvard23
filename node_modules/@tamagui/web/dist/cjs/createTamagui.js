var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var createTamagui_exports = {};
__export(createTamagui_exports, {
  createTamagui: () => createTamagui
});
module.exports = __toCommonJS(createTamagui_exports);
var import_constants = require("@tamagui/constants"), import_config = require("./config"), import_createVariables = require("./createVariables"), import_getThemeCSSRules = require("./helpers/getThemeCSSRules"), import_insertStyleRule = require("./helpers/insertStyleRule"), import_proxyThemeToParents = require("./helpers/proxyThemeToParents"), import_registerCSSVariable = require("./helpers/registerCSSVariable"), import_themes = require("./helpers/themes"), import_useMedia = require("./hooks/useMedia"), import_insertFont = require("./insertFont"), import_Tamagui = require("./Tamagui");
const createdConfigs = /* @__PURE__ */ new WeakMap();
function createTamagui(configIn) {
  var _a;
  if (createdConfigs.has(configIn))
    return configIn;
  const tokensParsed = {}, tokens = (0, import_createVariables.createVariables)(configIn.tokens || {});
  if (configIn.tokens) {
    const tokensMerged = {};
    for (const cat in tokens) {
      tokensParsed[cat] = {}, tokensMerged[cat] = {};
      const tokenCat = tokens[cat];
      for (const key in tokenCat) {
        const val = tokenCat[key], prefixedKey = `$${key}`;
        tokensParsed[cat][prefixedKey] = val, tokensMerged[cat][prefixedKey] = val, tokensMerged[cat][key] = val;
      }
    }
    (0, import_config.setTokens)(tokensMerged);
  }
  let foundThemes;
  if (configIn.themes) {
    const noThemes = Object.keys(configIn.themes).length === 0;
    foundThemes = (0, import_insertStyleRule.scanAllSheets)(noThemes, tokensParsed);
  }
  (0, import_insertStyleRule.listenForSheetChanges)();
  let fontSizeTokens = null, fontsParsed;
  if (configIn.fonts) {
    const fontTokens = Object.fromEntries(
      Object.entries(configIn.fonts).map(([k, v]) => [k, (0, import_createVariables.createVariables)(v, "f", !0)])
    );
    fontsParsed = (() => {
      const res = {};
      for (const familyName in fontTokens) {
        const font = fontTokens[familyName], fontParsed = (0, import_insertFont.parseFont)(font);
        res[`$${familyName}`] = fontParsed, !fontSizeTokens && fontParsed.size && (fontSizeTokens = new Set(Object.keys(fontParsed.size)));
      }
      return res;
    })();
  }
  const specificTokens = {}, themeConfig = (() => {
    const cssRuleSets = [];
    if (process.env.TAMAGUI_DOES_SSR_CSS !== "true" && // we can leave this out if mutating, only need the js for getThemeCSSRules
    process.env.TAMAGUI_DOES_SSR_CSS !== "mutates-themes") {
      const declarations = [], fontDeclarations = {};
      for (const key in tokens)
        for (const skey in tokens[key]) {
          const variable = tokens[key][skey];
          if (specificTokens[`$${key}.${skey}`] = variable, process.env.NODE_ENV === "development" && typeof variable > "u")
            throw new Error(
              `No value for tokens.${key}.${skey}:
${JSON.stringify(
                variable,
                null,
                2
              )}`
            );
          import_constants.isWeb && ((0, import_registerCSSVariable.registerCSSVariable)(variable), declarations.push((0, import_registerCSSVariable.variableToCSS)(variable, key === "zIndex")));
        }
      if (import_constants.isWeb) {
        let declarationsToRuleSet = function(decs, selector = "") {
          return `:root${selector} {${sep}${[...decs].join(`;${sep}`)}${sep}}`;
        };
        for (const key in fontsParsed) {
          const fontParsed = fontsParsed[key], [name, language] = key.includes("_") ? key.split("_") : [key], fontVars = (0, import_insertFont.registerFontVariables)(fontParsed);
          fontDeclarations[key] = {
            name: name.slice(1),
            declarations: fontVars,
            language
          };
        }
        const sep = process.env.NODE_ENV === "development" ? configIn.cssStyleSeparator || " " : "";
        if (cssRuleSets.push(declarationsToRuleSet(declarations)), fontDeclarations)
          for (const key in fontDeclarations) {
            const { name, declarations: declarations2, language = "default" } = fontDeclarations[key], fontSelector = `.font_${name}`, langSelector = `:root .t_lang-${name}-${language} ${fontSelector}`, selectors = language === "default" ? ` ${fontSelector}, ${langSelector}` : langSelector, specificRuleSet = declarationsToRuleSet(declarations2, selectors);
            cssRuleSets.push(specificRuleSet);
          }
      }
    }
    const themesIn = { ...configIn.themes }, dedupedThemes = foundThemes ?? getThemesDeduped(themesIn);
    return {
      themes: (0, import_proxyThemeToParents.proxyThemesToParents)(dedupedThemes),
      cssRuleSets,
      getThemeRulesSets() {
        let themeRuleSets = [];
        if (import_constants.isWeb)
          for (const { names, theme } of dedupedThemes) {
            const nextRules = (0, import_getThemeCSSRules.getThemeCSSRules)({
              config: configIn,
              themeName: names[0],
              names,
              theme
            });
            themeRuleSets = [...themeRuleSets, ...nextRules];
          }
        return themeRuleSets;
      }
    };
  })(), shorthands = configIn.shorthands || {};
  let lastCSSInsertedRulesIndex = -1;
  const getCSS = ({ separator = `
`, sinceLastCall, exclude } = {}) => {
    if (sinceLastCall && lastCSSInsertedRulesIndex >= 0) {
      const rules = (0, import_insertStyleRule.getAllRules)();
      return lastCSSInsertedRulesIndex = rules.length, rules.slice(lastCSSInsertedRulesIndex).join(separator);
    }
    lastCSSInsertedRulesIndex = 0;
    const runtimeStyles = (0, import_insertStyleRule.getAllRules)().join(separator);
    return exclude === "design-system" ? runtimeStyles : `${`._ovs-contain {overscroll-behavior:contain;}
.is_Text .is_Text {display:inline-flex;}
._dsp_contents {display:contents;}
${themeConfig.cssRuleSets.join(separator)}`}
${exclude ? "" : themeConfig.getThemeRulesSets().join(separator)}
${runtimeStyles}`;
  }, getNewCSS = (opts) => getCSS({ ...opts, sinceLastCall: !0 });
  let defaultFontName = configIn.defaultFont || // uses font named "body" if present for compat
  configIn.fonts && ("body" in configIn.fonts ? "body" : "");
  !defaultFontName && configIn.fonts && (defaultFontName = Object.keys(configIn.fonts)[0]), (defaultFontName == null ? void 0 : defaultFontName[0]) === "$" && (defaultFontName = defaultFontName.slice(1));
  const defaultFont = `$${defaultFontName}`, config = {
    fonts: {},
    settings: {},
    onlyAllowShorthands: !1,
    fontLanguages: [],
    animations: {},
    media: {},
    ...configIn,
    tokens,
    // vite made this into a function if it wasn't set
    shorthands,
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(([k, v]) => [v, k])) : {},
    themes: themeConfig.themes,
    fontsParsed: fontsParsed || {},
    themeConfig,
    tokensParsed,
    parsed: !0,
    getNewCSS,
    getCSS,
    defaultFont,
    fontSizeTokens: fontSizeTokens || /* @__PURE__ */ new Set(),
    specificTokens
    // const tokens = [...getToken(tokens.size[0])]
    // .spacer-sm + ._dsp_contents._dsp-sm-hidden { margin-left: -var(--${}) }
  };
  return (0, import_useMedia.configureMedia)(config), (0, import_config.setConfig)(config), import_config.configListeners.size && (import_config.configListeners.forEach((cb) => cb(config)), import_config.configListeners.clear()), createdConfigs.set(config, !0), process.env.NODE_ENV === "development" && ((_a = process.env.DEBUG) != null && _a.startsWith("tamagui") && console.info("Tamagui config:", config), globalThis.Tamagui || (globalThis.Tamagui = import_Tamagui.Tamagui)), config;
}
function getThemesDeduped(themes) {
  const dedupedThemes = [], existing = /* @__PURE__ */ new Map();
  for (const themeName in themes) {
    const darkOrLightSpecificPrefix = themeName.startsWith("dark") ? "dark" : themeName.startsWith("light") ? "light" : "", rawTheme = themes[themeName], key = darkOrLightSpecificPrefix + JSON.stringify(rawTheme);
    if (existing.has(key)) {
      existing.get(key).names.push(themeName);
      continue;
    }
    const theme = { ...rawTheme };
    for (const key2 in theme)
      (0, import_themes.ensureThemeVariable)(theme, key2);
    const deduped = {
      names: [themeName],
      theme
    };
    dedupedThemes.push(deduped), existing.set(key, deduped);
  }
  return dedupedThemes;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createTamagui
});
//# sourceMappingURL=createTamagui.js.map
