import {
  currentPlatform,
  isAndroid,
  isClient,
  isServer,
  isWeb,
  useIsomorphicLayoutEffect
} from "@tamagui/constants";
import {
  stylePropsText,
  stylePropsTransform,
  validPseudoKeys,
  validStyles,
  validStylesOnBaseProps
} from "@tamagui/helpers";
import { useInsertionEffect } from "react";
import { getConfig, getFont } from "../config";
import {
  accessibilityWebRoleToNativeRole,
  nativeAccessibilityState,
  nativeAccessibilityValue,
  webToNativeAccessibilityDirectMap
} from "../constants/accessibilityDirectMap";
import { isDevTools } from "../constants/isDevTools";
import {
  getMediaImportanceIfMoreImportant,
  mediaState as globalMediaState,
  isMediaKey,
  mediaKeyMatch,
  mediaQueryConfig,
  mergeMediaByImportance
} from "../hooks/useMedia";
import { createMediaStyle } from "./createMediaStyle";
import { fixStyles } from "./expandStyles";
import { getGroupPropParts } from "./getGroupPropParts";
import {
  generateAtomicStyles,
  getStylesAtomic,
  styleToCSS
} from "./getStylesAtomic";
import {
  insertStyleRules
} from "./insertStyleRule";
import {
  normalizeValueWithProperty
} from "./normalizeValueWithProperty";
import { getPropMappedFontFamily, propMapper } from "./propMapper";
import { pseudoDescriptors, pseudoPriorities } from "./pseudoDescriptors";
const fontFamilyKey = "fontFamily", IS_STATIC = process.env.IS_STATIC === "is_static";
let conf;
const PROP_SPLIT = "-", getSplitStyles = (props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug) => {
  conf = conf || getConfig();
  const { shorthands } = conf, {
    isHOC,
    isText,
    variants,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, validStyleProps = isText ? stylePropsText : validStyles, viewProps = {}, mediaState = styleProps.mediaState || globalMediaState, usedKeys = {}, shouldDoClasses = acceptsClassName && isWeb && !styleProps.noClassNames, rulesToInsert = [], classNames = {}, transforms = {};
  let pseudos = null, space = props.space, hasMedia = !1, dynamicThemeAccess, pseudoGroups, mediaGroups, style = {}, className = "", mediaStylesSeen = 0;
  const styleState = {
    curProps: Object.assign({}, props),
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style,
    theme,
    usedKeys,
    viewProps,
    context,
    debug
  };
  process.env.NODE_ENV === "development" && debug && debug !== "profile" && isClient && (console.groupCollapsed("getSplitStyles (collapsed)"), console.info({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    componentState,
    styleState,
    theme: { ...theme }
  }), console.groupEnd());
  for (const keyOg in props) {
    let keyInit = keyOg, valInit = props[keyOg];
    if (styleProps.disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className" || keyInit in usedKeys || keyInit in skipProps && !isHOC)
      continue;
    const valInitType = typeof valInit;
    if (styleState.curProps[keyInit] = valInit, !isAndroid && keyInit === "elevationAndroid")
      continue;
    if (keyInit === "userSelect")
      keyInit = "selectable", valInit = valInit !== "none";
    else if (keyInit === "role") {
      viewProps.accessibilityRole = accessibilityWebRoleToNativeRole[valInit];
      continue;
    } else if (keyInit.startsWith("aria-")) {
      if (webToNativeAccessibilityDirectMap[keyInit]) {
        const nativeA11yProp = webToNativeAccessibilityDirectMap[keyInit];
        keyInit === "aria-hidden" && (viewProps["aria-hidden"] = valInit), viewProps[nativeA11yProp] = valInit;
        continue;
      } else if (nativeAccessibilityValue[keyInit]) {
        let field = nativeAccessibilityValue[keyInit];
        viewProps.accessibilityValue ? viewProps.accessibilityValue[field] = valInit : viewProps.accessibilityValue = {
          [field]: valInit
        };
      } else if (nativeAccessibilityState[keyInit]) {
        let field = nativeAccessibilityState[keyInit];
        viewProps.accessibilityState ? viewProps.accessibilityState[field] = valInit : viewProps.accessibilityState = {
          [field]: valInit
        };
      }
      continue;
    } else if (keyInit.startsWith("data-"))
      continue;
    if (keyInit === "dataSet") {
      for (const keyInit2 in valInit)
        viewProps[`data-${hyphenate(keyInit2)}`] = valInit[keyInit2];
      continue;
    }
    if (keyInit[0] === "_" && keyInit.startsWith("_style")) {
      mergeStyleProp(styleState, valInit);
      continue;
    }
    if (!1 && !styleProps.noExpand && !isReactNative) {
      if (!(keyInit in accessibilityDirectMap))
        switch (keyInit) {
          case "accessibilityRole":
          case "accessibilityLabelledBy":
          case "accessibilityFlowTo":
          case "accessibilityControls":
          case "accessibilityDescribedBy":
          case "accessibilityKeyShortcuts":
          case "accessibilityLiveRegion":
          case "accessibilityReadOnly":
          case "accessibilityRequired":
          default:
        }
    }
    const isValidStyleKeyInit = keyInit in validStyleProps, isShorthand = keyInit in shorthands;
    let isVariant = !isValidStyleKeyInit && variants && keyInit in variants;
    const isStyleLikeKey = isShorthand || isValidStyleKeyInit || isVariant;
    let isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo && isMediaKey(keyInit), isMediaOrPseudo = !!(isMedia || isPseudo);
    const isStyleProp = isMediaOrPseudo || isVariant && !styleProps.noExpand || isValidStyleKeyInit || isShorthand;
    if (isStyleProp && (props.asChild === "except-style" || props.asChild === "except-style-web"))
      continue;
    const shouldPassProp = !isStyleProp || // is in parent variants
    isHOC && parentStaticConfig?.variants && keyInit in parentStaticConfig.variants || inlineProps?.has(keyInit), parentVariant = parentStaticConfig?.variants?.[keyInit], isHOCShouldPassThrough = !!(isHOC && (isShorthand || isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed(
      `\u{1F539}\u{1F539}\u{1F539}\u{1F539} ${keyOg}${keyInit !== keyOg ? ` (shorthand for ${keyInit})` : ""} ${shouldPassThrough ? "(pass)" : ""} \u{1F539}\u{1F539}\u{1F539}\u{1F539}`
    ), console.info({ isVariant, valInit, shouldPassProp }), isClient && console.info({
      variants,
      variant: variants?.[keyInit],
      isVariant,
      isHOCShouldPassThrough,
      curProps: { ...styleState.curProps },
      parentStaticConfig
    }), console.groupEnd()), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant) || !styleProps.noSkip && keyInit in skipProps)
      continue;
    if (isText && valInit && (keyInit === fontFamilyKey || keyInit === shorthands[fontFamilyKey]) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit), isValidStyleKeyInit && !variants && (valInitType === "number" || valInitType === "string" && valInit[0] !== "$")) {
      style[keyInit] = valInit;
      continue;
    }
    const expanded = isMediaOrPseudo || !isVariant && !isValidStyleKeyInit ? [[keyInit, valInit]] : propMapper(keyInit, valInit, styleState), next = getPropMappedFontFamily(expanded);
    if (next && (styleState.fontFamily = next), process.env.NODE_ENV === "development" && debug === "verbose") {
      console.groupCollapsed("  \u{1F4A0} expanded", keyInit, valInit);
      try {
        !isServer && isDevTools && (console.info({
          expanded,
          styleProps,
          componentState,
          isVariant,
          variant: variants?.[keyInit],
          shouldPassProp,
          isHOCShouldPassThrough,
          theme,
          usedKeys: { ...usedKeys },
          curProps: { ...styleState.curProps }
        }), console.info("expanded", expanded, `
usedKeys`, { ...usedKeys }, `
current`, {
          ...style
        }));
      } catch {
      }
      console.groupEnd();
    }
    if (expanded) {
      for (const [key, val] of expanded) {
        if (val == null || key in usedKeys)
          continue;
        if (isPseudo = key in validPseudoKeys, isMedia = !isPseudo && !isValidStyleKeyInit && isMediaKey(key), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants && key in variants, (inlineProps?.has(key) || IS_STATIC && inlineWhenUnflattened?.has(key)) && (viewProps[key] = props[key] ?? val), styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo || parentStaticConfig?.variants?.[keyInit])) {
          passDownProp(viewProps, key, val, isMediaOrPseudo), process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed(` - passing down prop ${key}`), console.info({ val, after: { ...viewProps[key] } }), console.groupEnd());
          continue;
        }
        if (isPseudo) {
          if (!val)
            continue;
          const pseudoStyleObject = getSubStyle(
            styleState,
            key,
            val,
            styleProps.noClassNames
          ), descriptor = pseudoDescriptors[key], isEnter = key === "enterStyle", isExit = key === "exitStyle";
          if (process.env.NODE_ENV === "development" && !styleProps.isAnimated && !componentState.unmounted && (isEnter || isExit) && console.warn(
            `No animation prop given to component ${staticConfig.componentName || ""} ${props["data-at"] || ""} with enterStyle / exitStyle, these styles will be ignored`,
            { props }
          ), !descriptor || isExit && !styleProps.isExiting)
            continue;
          if ((!shouldDoClasses || IS_STATIC) && (pseudos ||= {}, pseudos[key] ||= {}, IS_STATIC)) {
            Object.assign(pseudos[key], pseudoStyleObject);
            continue;
          }
          if (shouldDoClasses && !isEnter && !isExit) {
            const pseudoStyles = generateAtomicStyles(pseudoStyleObject, descriptor);
            process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("pseudo (classes)", key), console.info({ pseudoStyleObject, pseudoStyles }), console.groupEnd());
            for (const psuedoStyle of pseudoStyles) {
              const fullKey = `${psuedoStyle.property}${PROP_SPLIT}${descriptor.name}`;
              fullKey in usedKeys || (psuedoStyle.identifier, void 0);
            }
          } else {
            const descriptorKey = descriptor.stateKey || descriptor.name, pseudoState = componentState[descriptorKey];
            let isDisabled = isExit ? !styleProps.isExiting : !pseudoState;
            isWeb && !isClient && isEnter && (isDisabled = !1), process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("pseudo", key, { isDisabled }), console.info(pseudoStyleObject, {
              isDisabled,
              descriptorKey,
              descriptor,
              pseudoState,
              state: { ...componentState }
            }), console.groupEnd());
            const importance = descriptor.priority;
            for (const pkey in pseudoStyleObject) {
              const val2 = pseudoStyleObject[pkey];
              if (isDisabled) {
                if (pkey in animatableDefaults && !(pkey in usedKeys)) {
                  const defaultVal = animatableDefaults[pkey];
                  mergeStyle(styleState, pkey, defaultVal);
                }
              } else {
                const curImportance = usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
                shouldMerge && (pseudos ||= {}, pseudos[key] ||= {}, pseudos[key][pkey] = val2, mergeStyle(styleState, pkey, val2)), process.env.NODE_ENV === "development" && debug === "verbose" && console.info("    subKey", pkey, shouldMerge, {
                  importance,
                  curImportance,
                  pkey,
                  val: val2,
                  transforms: { ...styleState.transforms }
                });
              }
            }
            if (!isDisabled)
              for (const key2 in val) {
                const k = shorthands[key2] || key2;
                usedKeys[k] = Math.max(importance, usedKeys[k] || 0);
              }
          }
          continue;
        } else if (isMedia) {
          if (!val)
            continue;
          if (isMedia === "platform") {
            const platform = key.slice(10);
            if (
              // supports web, ios, android
              platform !== currentPlatform && // supports web, native
              platform !== "native"
            )
              continue;
          }
          hasMedia ||= !0;
          const mediaStyle = getSubStyle(
            styleState,
            key,
            val,
            // TODO try true like pseudo
            !1
          ), mediaKeyShort = key.slice(1);
          process.env.NODE_ENV === "development" && debug === "verbose" && console.info(`  \u{1F4FA} ${key}`, {
            key,
            val,
            mediaStyle,
            props,
            shouldDoClasses,
            componentState
          });
          const hasSpace = val.space;
          if ((hasSpace || !shouldDoClasses) && (Array.isArray(hasMedia) || (hasMedia = []), hasMedia.push(mediaKeyShort)), shouldDoClasses) {
            if (hasSpace && (delete mediaStyle.space, mediaState[mediaKeyShort])) {
              const importance = getMediaImportanceIfMoreImportant(
                mediaKeyShort,
                "space",
                usedKeys,
                !0
              );
              importance && (space = val.space, usedKeys.space = importance, process.env.NODE_ENV === "development" && debug === "verbose" && console.info(
                `Found more important space for current media ${mediaKeyShort}: ${val} (importance: ${importance})`
              ));
            }
            const mediaStyles = getStylesAtomic(mediaStyle, debug), priority = mediaStylesSeen;
            mediaStylesSeen += 1;
            for (const style2 of mediaStyles) {
              const out = createMediaStyle(
                style2,
                mediaKeyShort,
                mediaQueryConfig,
                isMedia,
                !1,
                priority
              ), fullKey = `${style2.property}${PROP_SPLIT}${mediaKeyShort}`;
              fullKey in usedKeys || (out.identifier, void 0);
            }
          } else {
            const isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group";
            if (!isThemeMedia && !(isMedia === "platform") && !isGroupMedia && !mediaState[mediaKeyShort])
              continue;
            let importanceBump = 0;
            if (isThemeMedia) {
              dynamicThemeAccess = !0;
              const mediaThemeName = mediaKeyShort.slice(6);
              if (!(themeName === mediaThemeName || themeName.startsWith(mediaThemeName)))
                continue;
            } else if (isGroupMedia) {
              const groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupContext = context?.groups.state[groupName];
              if (!groupContext) {
                process.env.NODE_ENV === "development" && debug && console.warn(`No parent with group prop, skipping styles: ${groupName}`);
                continue;
              }
              const groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media, componentGroupState = componentState.group?.[groupName];
              if (groupMediaKey) {
                mediaGroups ||= /* @__PURE__ */ new Set(), mediaGroups.add(groupMediaKey);
                const mediaState2 = componentGroupState?.media;
                let isActive = mediaState2?.[groupMediaKey];
                if (!mediaState2 && groupContext.layout && (isActive = mediaKeyMatch(groupMediaKey, groupContext.layout)), !isActive)
                  continue;
                importanceBump = 2;
              }
              if (groupPseudoKey) {
                if (pseudoGroups ||= /* @__PURE__ */ new Set(), pseudoGroups.add(groupName), !(componentGroupState || // fallback to context initially
                context.groups.state[groupName]).pseudo?.[groupPseudoKey])
                  continue;
                importanceBump = pseudoPriorities[groupPseudoKey];
              }
            }
            for (const subKey in mediaStyle) {
              if (subKey === "space") {
                space = valInit.space;
                continue;
              }
              mergeMediaByImportance(
                style,
                mediaKeyShort,
                subKey,
                mediaStyle[subKey],
                usedKeys,
                mediaState[mediaKeyShort],
                importanceBump
              ), key === fontFamilyKey && (styleState.fontFamily = mediaStyle.fontFamily);
            }
          }
          continue;
        }
        if (key === "pointerEvents") {
          viewProps[key] = val;
          continue;
        }
        if (
          // is HOC we can just pass through the styles as props
          // this fixes issues where style prop got merged with wrong priority
          !isHOC && (key in validStyleProps || isAndroid && key === "elevation")
        ) {
          mergeStyle(styleState, key, val);
          continue;
        }
        isVariant || (viewProps[key] = val);
      }
      if (process.env.NODE_ENV === "development" && debug === "verbose") {
        console.groupCollapsed(" \u2714\uFE0F expand complete", keyInit);
        try {
          console.info("style", { ...style }), console.info("transforms", { ...transforms }), console.info("viewProps", { ...viewProps });
        } catch {
        }
        console.groupEnd();
      }
    }
  }
  if (props.style && mergeStyleProp(styleState, props.style), !styleProps.noNormalize && (fixStyles(style), isWeb && !staticConfig.isReactNative && styleToCSS(style), styleState.transforms && Object.entries(styleState.transforms).sort(([a], [b]) => a.localeCompare(b)).forEach(([key, val]) => {
    mergeTransform(style, key, val, !0);
  }), parentSplitStyles && !shouldDoClasses))
    for (const key in parentSplitStyles.style)
      key in classNames || key in style || (style[key] = parentSplitStyles.style[key]);
  const result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    // @ts-expect-error
    style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  };
  if (style.fontFamily) {
    const faceInfo = getFont(style.fontFamily)?.face;
    if (faceInfo) {
      const overrideFace = faceInfo[style.fontWeight]?.[style.fontStyle || "normal"]?.val;
      overrideFace && (style.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style.fontWeight, delete style.fontStyle);
    }
    process.env.NODE_ENV === "development" && debug && debug !== "profile" && console.info(`Found fontFamily native: ${style.fontFamily}`, faceInfo);
  }
  if (className && (classNames.className = className), process.env.NODE_ENV === "development" && debug === "verbose" && isDevTools) {
    console.groupCollapsed("  \u{1F539} ===>");
    try {
      const logs = {
        ...result,
        className,
        componentState,
        transforms,
        viewProps,
        viewPropsOrder: Object.keys(viewProps),
        rulesToInsert,
        parentSplitStyles
      };
      for (const key in logs)
        console.info(key, logs[key]);
    } catch {
    }
    console.groupEnd();
  }
  return result;
};
function mergeStyle(styleState, key, val) {
  const { classNames, viewProps, style, usedKeys, styleProps } = styleState;
  if (isWeb && val?.[0] === "_")
    classNames[key] = val, usedKeys[key] ||= 1;
  else if (key in stylePropsTransform)
    styleState.transforms ||= {}, styleState.transforms[key] = val;
  else {
    const out = isWeb && !styleProps.noNormalize ? normalizeValueWithProperty(val, key) : val;
    key in validStylesOnBaseProps ? viewProps[key] = out : style[key] = out;
  }
}
const getSubStyle = (styleState, subKey, styleIn, avoidMergeTransform) => {
  const { staticConfig, props, conf: conf2, styleProps } = styleState, styleOut = {};
  for (let key in styleIn) {
    const val = styleIn[key];
    key = conf2.shorthands[key] || key;
    const expanded = propMapper(key, val, styleState, { ...props, ...props[subKey] });
    if (!(!expanded || !staticConfig.isHOC && key in skipProps && !styleProps.noSkip))
      for (const [skey, sval] of expanded)
        !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : normalizeValueWithProperty(sval, key);
  }
  return styleProps.noNormalize || fixStyles(styleOut), styleOut;
};
function mergeStyleProp(styleState, val) {
  if (!val)
    return;
  const styles = [].concat(val).flat();
  for (const cur of styles) {
    if (!cur)
      continue;
    if (cur.$$css)
      Object.assign(styleState.classNames, cur);
    else
      for (const key in cur)
        key in styleState.usedKeys || mergeStyle(styleState, key, cur[key]);
  }
}
const useInsertEffectCompat = isWeb ? useInsertionEffect || useIsomorphicLayoutEffect : () => {
}, useSplitStyles = (...args) => {
  const res = getSplitStyles(...args);
  return useInsertEffectCompat(() => {
    insertStyleRules(res.rulesToInsert);
  }, [res.rulesToInsert]), res;
};
const animatableDefaults = {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0
}, lowercaseHyphenate = (match) => `-${match.toLowerCase()}`, hyphenate = (str) => str.replace(/[A-Z]/g, lowercaseHyphenate), mergeTransform = (obj, key, val, backwards = !1) => {
  typeof obj.transform != "string" && (obj.transform ||= [], obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
}, skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1
};
process.env.NODE_ENV === "test" && (skipProps["data-test-renders"] = 1);
Object.assign(skipProps, {
  whiteSpace: 1,
  wordWrap: 1,
  textOverflow: 1,
  textDecorationDistance: 1,
  cursor: 1,
  contain: 1,
  boxSizing: 1,
  boxShadow: 1,
  outlineStyle: 1,
  outlineOffset: 1,
  outlineWidth: 1,
  outlineColor: 1
});
function passDownProp(viewProps, key, val, shouldMergeObject = !1) {
  if (shouldMergeObject) {
    const next = {
      ...viewProps[key],
      ...val
    };
    delete viewProps[key], viewProps[key] = next;
  } else
    viewProps[key] = val;
}
export {
  PROP_SPLIT,
  getSplitStyles,
  getSubStyle,
  useSplitStyles
};
//# sourceMappingURL=getSplitStyles.js.map
