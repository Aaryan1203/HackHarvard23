var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var Slider_exports = {};
__export(Slider_exports, {
  Range: () => Range,
  Slider: () => Slider,
  SliderThumb: () => SliderThumb,
  SliderThumbFrame: () => SliderThumbFrame,
  SliderTrack: () => SliderTrack,
  SliderTrackActive: () => SliderTrackActive,
  SliderTrackActiveFrame: () => SliderTrackActiveFrame,
  SliderTrackFrame: () => SliderTrackFrame,
  Thumb: () => Thumb,
  Track: () => Track
});
module.exports = __toCommonJS(Slider_exports);
var import_compose_refs = require("@tamagui/compose-refs"), import_core = require("@tamagui/core"), import_get_token = require("@tamagui/get-token"), import_helpers = require("@tamagui/helpers"), import_stacks = require("@tamagui/stacks"), import_use_controllable_state = require("@tamagui/use-controllable-state"), import_use_direction = require("@tamagui/use-direction"), React = __toESM(require("react")), import_constants = require("./constants"), import_helpers2 = require("./helpers"), import_SliderImpl = require("./SliderImpl"), import_jsx_runtime = require("react/jsx-runtime");
const SliderHorizontal = React.forwardRef(
  (props, forwardedRef) => {
    const {
      min,
      max,
      dir,
      onSlideStart,
      onSlideMove,
      onStepKeyDown,
      onSlideEnd,
      ...sliderProps
    } = props, direction = (0, import_use_direction.useDirection)(dir), isDirectionLTR = direction === "ltr", sliderRef = React.useRef(null), [state, setState_] = React.useState(() => ({ size: 0, offset: 0 })), setState = (0, import_core.createShallowSetState)(setState_);
    function getValueFromPointer(pointerPosition) {
      const input = [0, state.size];
      return (0, import_helpers2.linearScale)(input, isDirectionLTR ? [min, max] : [max, min])(pointerPosition);
    }
    const measure = () => {
      var _a;
      (_a = sliderRef.current) == null || _a.measure((_x, _y, width, _height, pageX, _pageY) => {
        setState({
          size: width,
          offset: pageX
        });
      });
    };
    return import_core.isClient && useOnDebouncedWindowResize(measure), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_constants.SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isDirectionLTR ? "left" : "right",
        endEdge: isDirectionLTR ? "right" : "left",
        direction: isDirectionLTR ? 1 : -1,
        sizeProp: "width",
        size: state.size,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_SliderImpl.SliderImpl,
          {
            ref: (0, import_compose_refs.composeRefs)(forwardedRef, sliderRef),
            dir: direction,
            ...sliderProps,
            orientation: "horizontal",
            onLayout: measure,
            onSlideStart: (event, target) => {
              const value = getValueFromPointer(event.nativeEvent.locationX);
              value && (onSlideStart == null || onSlideStart(value, target, event));
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
              value && (onSlideMove == null || onSlideMove(value, event));
            },
            onSlideEnd: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
              value && (onSlideEnd == null || onSlideEnd(event, value));
            },
            onStepKeyDown: (event) => {
              const isBackKey = import_constants.BACK_KEYS[direction].includes(event.key);
              onStepKeyDown == null || onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
function useOnDebouncedWindowResize(callback, amt = 200) {
  React.useEffect(() => {
    let last;
    const onResize = () => {
      clearTimeout(last), last = setTimeout(callback, amt);
    };
    return window.addEventListener("resize", onResize), () => {
      clearTimeout(last), window.removeEventListener("resize", onResize);
    };
  }, []);
}
const SliderVertical = React.forwardRef(
  (props, forwardedRef) => {
    const {
      min,
      max,
      onSlideStart,
      onSlideMove,
      onStepKeyDown,
      onSlideEnd,
      ...sliderProps
    } = props, [state, setState_] = React.useState(() => ({ size: 0, offset: 0 })), setState = (0, import_core.createShallowSetState)(setState_), sliderRef = React.useRef(null);
    function getValueFromPointer(pointerPosition) {
      const input = [0, state.size];
      return (0, import_helpers2.linearScale)(input, [max, min])(pointerPosition);
    }
    const measure = () => {
      var _a;
      (_a = sliderRef.current) == null || _a.measure((_x, _y, _width, height, _pageX, pageY) => {
        setState({
          size: height,
          offset: pageY
        });
      });
    };
    return import_core.isClient && useOnDebouncedWindowResize(measure), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_constants.SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: "bottom",
        endEdge: "top",
        sizeProp: "height",
        size: state.size,
        direction: 1,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_SliderImpl.SliderImpl,
          {
            ref: (0, import_compose_refs.composeRefs)(forwardedRef, sliderRef),
            ...sliderProps,
            orientation: "vertical",
            onLayout: measure,
            onSlideStart: (event, target) => {
              const value = getValueFromPointer(event.nativeEvent.locationY);
              value && (onSlideStart == null || onSlideStart(value, target, event));
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
              value && (onSlideMove == null || onSlideMove(value, event));
            },
            onSlideEnd: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
              onSlideEnd == null || onSlideEnd(event, value);
            },
            onStepKeyDown: (event) => {
              const isBackKey = import_constants.BACK_KEYS.ltr.includes(event.key);
              onStepKeyDown == null || onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), TRACK_NAME = "SliderTrack", SliderTrackFrame = (0, import_core.styled)(import_SliderImpl.SliderFrame, {
  name: "SliderTrack",
  variants: {
    unstyled: {
      false: {
        height: "100%",
        width: "100%",
        backgroundColor: "$background",
        position: "relative",
        borderRadius: 1e5,
        overflow: "hidden"
      }
    }
  },
  defaultVariants: {
    unstyled: !1
  }
}), SliderTrack = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props, context = (0, import_constants.useSliderContext)(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      SliderTrackFrame,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        orientation: context.orientation,
        size: context.size,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
const RANGE_NAME = "SliderTrackActive", SliderTrackActiveFrame = (0, import_core.styled)(import_SliderImpl.SliderFrame, {
  name: "SliderTrackActive",
  backgroundColor: "$background",
  position: "absolute"
}), SliderTrackActive = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props, context = (0, import_constants.useSliderContext)(RANGE_NAME, __scopeSlider), orientation = (0, import_constants.useSliderOrientationContext)(RANGE_NAME, __scopeSlider), ref = React.useRef(null), composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, ref), valuesCount = context.values.length, percentages = context.values.map(
      (value) => (0, import_helpers2.convertValueToPercentage)(value, context.min, context.max)
    ), offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0, offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      SliderTrackActiveFrame,
      {
        orientation: context.orientation,
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        size: context.size,
        animateOnly: ["left", "top", "right", "bottom"],
        ...rangeProps,
        ref: composedRefs,
        [orientation.startEdge]: `${offsetStart}%`,
        [orientation.endEdge]: `${offsetEnd}%`,
        ...orientation.sizeProp === "width" ? {
          height: "100%"
        } : {
          left: 0,
          right: 0
        }
      }
    );
  }
);
SliderTrackActive.displayName = RANGE_NAME;
const THUMB_NAME = "SliderThumb", getThumbSize = (val) => {
  const tokens = (0, import_core.getTokens)(), size = typeof val == "number" ? val : (0, import_get_token.getSize)(tokens.size[val], {
    shift: -1
  });
  return {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size
  };
}, SliderThumbFrame = (0, import_core.styled)(import_stacks.ThemeableStack, {
  name: "SliderThumb",
  variants: {
    size: {
      "...size": getThumbSize
    },
    unstyled: {
      false: {
        position: "absolute",
        bordered: 2,
        borderWidth: 2,
        backgrounded: !0,
        pressTheme: import_core.isWeb,
        focusTheme: import_core.isWeb,
        hoverTheme: import_core.isWeb
      }
    }
  },
  defaultVariants: {
    unstyled: !1
  }
}), SliderThumb = SliderThumbFrame.styleable(function(props, forwardedRef) {
  const { __scopeSlider, index, size: sizeProp, ...thumbProps } = props, context = (0, import_constants.useSliderContext)(THUMB_NAME, __scopeSlider), orientation = (0, import_constants.useSliderOrientationContext)(THUMB_NAME, __scopeSlider), [thumb, setThumb] = React.useState(null), composedRefs = (0, import_compose_refs.useComposedRefs)(
    forwardedRef,
    (node) => setThumb(node)
  ), value = context.values[index], percent = value === void 0 ? 0 : (0, import_helpers2.convertValueToPercentage)(value, context.min, context.max), label = (0, import_helpers2.getLabel)(index, context.values.length), sizeIn = sizeProp ?? context.size ?? "$true", [size, setSize] = React.useState(() => (0, import_core.getVariableValue)(getThumbSize(sizeIn).width)), thumbInBoundsOffset = size ? (0, import_helpers2.getThumbInBoundsOffset)(size, percent, orientation.direction) : 0;
  React.useEffect(() => {
    if (thumb)
      return context.thumbs.add(thumb), () => {
        context.thumbs.delete(thumb);
      };
  }, [thumb, context.thumbs]);
  const positionalStyles = context.orientation === "horizontal" ? {
    x: thumbInBoundsOffset - size / 2,
    y: -size / 2,
    top: "50%",
    ...size === 0 && {
      top: "auto",
      bottom: "auto"
    }
  } : {
    x: -size / 2,
    y: size / 2,
    left: "50%",
    ...size === 0 && {
      left: "auto",
      right: "auto"
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    SliderThumbFrame,
    {
      ref: composedRefs,
      role: "slider",
      "aria-label": props["aria-label"] || label,
      "aria-valuemin": context.min,
      "aria-valuenow": value,
      "aria-valuemax": context.max,
      "aria-orientation": context.orientation,
      "data-orientation": context.orientation,
      "data-disabled": context.disabled ? "" : void 0,
      tabIndex: context.disabled ? void 0 : 0,
      animateOnly: ["transform", "left", "top", "right", "bottom"],
      ...positionalStyles,
      [orientation.startEdge]: `${percent}%`,
      size: sizeIn,
      ...thumbProps,
      onLayout: (e) => {
        setSize(e.nativeEvent.layout[orientation.sizeProp]);
      },
      onFocus: (0, import_helpers.composeEventHandlers)(props.onFocus, () => {
        context.valueIndexToChangeRef.current = index;
      })
    }
  );
}), SliderComponent = React.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min = 0,
      max = 100,
      step = 1,
      orientation = "horizontal",
      disabled = !1,
      minStepsBetweenThumbs = 0,
      defaultValue = [min],
      value,
      onValueChange = () => {
      },
      size: sizeProp,
      onSlideEnd,
      onSlideMove,
      onSlideStart,
      ...sliderProps
    } = props, sliderRef = React.useRef(null), composedRefs = (0, import_compose_refs.useComposedRefs)(sliderRef, forwardedRef), thumbRefs = React.useRef(/* @__PURE__ */ new Set()), valueIndexToChangeRef = React.useRef(0), isHorizontal = orientation === "horizontal", [values = [], setValues] = (0, import_use_controllable_state.useControllableState)({
      prop: value,
      defaultProp: defaultValue,
      transition: !0,
      onChange: (value2) => {
        var _a;
        import_core.isWeb && ((_a = [...thumbRefs.current][valueIndexToChangeRef.current]) == null || _a.focus()), onValueChange(value2);
      }
    });
    import_core.isWeb && React.useEffect(() => {
      const node = sliderRef.current;
      if (!node)
        return;
      const preventDefault = (e) => {
        e.preventDefault();
      };
      return node.addEventListener("touchstart", preventDefault), () => {
        node.removeEventListener("touchstart", preventDefault);
      };
    }, []);
    function handleSlideMove(value2, event) {
      updateValues(value2, valueIndexToChangeRef.current), onSlideMove == null || onSlideMove(event, value2);
    }
    function updateValues(value2, atIndex) {
      const decimalCount = (0, import_helpers2.getDecimalCount)(step), snapToStep = (0, import_helpers2.roundValue)(
        Math.round((value2 - min) / step) * step + min,
        decimalCount
      ), nextValue = (0, import_helpers.clamp)(snapToStep, [min, max]);
      setValues((prevValues = []) => {
        const nextValues = (0, import_helpers2.getNextSortedValues)(prevValues, nextValue, atIndex);
        return (0, import_helpers2.hasMinStepsBetweenValues)(nextValues, minStepsBetweenThumbs * step) ? (valueIndexToChangeRef.current = nextValues.indexOf(nextValue), String(nextValues) === String(prevValues) ? prevValues : nextValues) : prevValues;
      });
    }
    const SliderOriented = isHorizontal ? SliderHorizontal : SliderVertical;
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_constants.SliderProvider,
      {
        scope: props.__scopeSlider,
        disabled,
        min,
        max,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        size: sizeProp,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          SliderOriented,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: composedRefs,
            min,
            max,
            onSlideEnd,
            onSlideStart: disabled ? void 0 : (value2, target, event) => {
              if (target !== "thumb") {
                const closestIndex = (0, import_helpers2.getClosestValueIndex)(values, value2);
                updateValues(value2, closestIndex), onSlideStart == null || onSlideStart(event, value2, target);
              }
            },
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onHomeKeyDown: () => !disabled && updateValues(min, 0),
            onEndKeyDown: () => !disabled && updateValues(max, values.length - 1),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const multiplier = import_constants.PAGE_KEYS.includes(event.key) || event.shiftKey && import_constants.ARROW_KEYS.includes(event.key) ? 10 : 1, atIndex = valueIndexToChangeRef.current, value2 = values[atIndex], stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex);
              }
            }
          }
        )
      }
    );
  }
), Slider = (0, import_core.withStaticProperties)(SliderComponent, {
  Track: SliderTrack,
  TrackActive: SliderTrackActive,
  Thumb: SliderThumb
});
Slider.displayName = import_constants.SLIDER_NAME;
const Track = SliderTrack, Range = SliderTrackActive, Thumb = SliderThumb;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Range,
  Slider,
  SliderThumb,
  SliderThumbFrame,
  SliderTrack,
  SliderTrackActive,
  SliderTrackActiveFrame,
  SliderTrackFrame,
  Thumb,
  Track
});
//# sourceMappingURL=Slider.js.map
