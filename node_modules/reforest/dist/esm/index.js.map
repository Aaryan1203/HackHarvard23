{"version":3,"sources":["../../src/use-indexed-children.tsx","../../src/contexts.ts","../../src/utils.ts","../../src/use-roving-index.ts","../../src/use-tree.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { MaxIndexContext, IndexContext } from \"./contexts\"\nimport { parseIndexPath } from \"./utils\"\n\n/** Returns the index path data based on the closest useIndexedChildren. */\nexport function useIndex() {\n  const maxIndexPath = React.useContext(MaxIndexContext)\n  const indexPathString = React.useContext(IndexContext)\n\n  return React.useMemo(() => {\n    if (indexPathString === null) {\n      return null\n    }\n\n    const indexPath = parseIndexPath(indexPathString)\n    const maxIndex = maxIndexPath[maxIndexPath.length - 1]\n    const index = indexPath[indexPath.length - 1]\n\n    return {\n      maxIndex,\n      maxIndexPath,\n      index,\n      indexPath,\n      indexPathString,\n      isFirst: index === 0,\n      isLast: index === maxIndex,\n      isEven: index % 2 === 0,\n      isOdd: Math.abs(index % 2) === 1,\n    }\n  }, [maxIndexPath, indexPathString])\n}\n\n/** Provides the current index path for each child. */\nexport function useIndexedChildren(children: React.ReactNode) {\n  const parentMaxIndexPath = React.useContext(MaxIndexContext)\n  const indexPathString = React.useContext(IndexContext)\n  const childrenCount = React.Children.count(children)\n  const maxIndexPath = React.useMemo(\n    () => parentMaxIndexPath.concat(childrenCount - 1),\n    [childrenCount]\n  )\n\n  return (\n    <MaxIndexContext.Provider value={maxIndexPath}>\n      {React.Children.map(children, (child, index) =>\n        React.isValidElement(child) ? (\n          <IndexContext.Provider\n            key={child.key}\n            value={indexPathString ? `${indexPathString}.${index.toString()}` : index.toString()}\n          >\n            {child}\n          </IndexContext.Provider>\n        ) : (\n          child\n        )\n      )}\n    </MaxIndexContext.Provider>\n  )\n}\n","import * as React from \"react\"\nimport type { UseBoundStore, StoreApi } from \"zustand\"\n\nexport const PrerenderContext = React.createContext(false)\n\nPrerenderContext.displayName = \"PrerenderContext\"\n\nexport const MaxIndexContext = React.createContext<number[]>([])\n\nMaxIndexContext.displayName = \"MaxIndexContext\"\n\nexport const IndexContext = React.createContext<string | null>(null)\n\nIndexContext.displayName = \"IndexContext\"\n\nexport type TreeState = {\n  treeMap: Map<string, any>\n  prerenderedTreeIds: Map<string, string>\n  shouldPrerender: boolean\n  setTreeData: (key: string, value: any, shouldUpdate?: boolean) => void\n  deleteTreeData: (key: string, shouldUpdate?: boolean) => void\n}\n\nexport type TreeStateStore = UseBoundStore<StoreApi<TreeState>>\n\nexport const TreeStateContext = React.createContext<TreeStateStore | null>(null)\n\nTreeStateContext.displayName = \"TreeStateContext\"\n","import * as React from \"react\"\nimport { arrayToTree } from \"performant-array-to-tree\"\n\nexport const isServer = typeof window === \"undefined\"\n\nexport const useIsomorphicLayoutEffect = isServer ? React.useEffect : React.useLayoutEffect\n\n/**\n * Parses a numerical dot-separated string as an index path.\n *\n * @example\n * parseIndexPath('0.10.2') -> [0, 10, 2]\n */\nexport function parseIndexPath(indexPathString: string) {\n  return indexPathString.split(\".\").map((index) => parseInt(index, 10))\n}\n\n/**\n * Compares two index path strings.\n * Credit: https://twitter.com/katylava/status/1558222958702780418\n */\nexport function compareIndexPaths(a: string = \"\", b: string = \"\") {\n  let aArray = a.split(\".\").map(Number)\n  let bArray = b.split(\".\").map(Number)\n\n  if (aArray.includes(NaN) || bArray.includes(NaN)) {\n    throw new Error(\"Version contains parts that are not numbers\")\n  }\n\n  const maxLength = Math.max(a.length, b.length)\n\n  for (let index = 0; index < maxLength; index++) {\n    const difference = (aArray[index] ?? 0) - (bArray[index] ?? 0)\n\n    if (difference === 0) {\n      continue\n    }\n\n    return difference > 0 ? 1 : -1\n  }\n\n  return 0\n}\n\n/** Recursive function that removes \"id\" and \"parentId\" keys and returns each indexed data. */\nexport function cleanAndSortTree(tree: any) {\n  if (tree.children?.length > 0) {\n    /** Sort children by the index path. */\n    tree.children.sort((a, b) => compareIndexPaths(a.indexPathString, b.indexPathString))\n\n    return {\n      ...tree.data,\n      children: tree.children.map(cleanAndSortTree),\n    }\n  }\n\n  return tree.data\n}\n\n/** Builds an array of trees from a Map of data collected in useTree. */\nexport function mapToChildren(dataMap: Map<string, any>): Array<any> {\n  const parsedValues = Array.from(dataMap.entries()).map(([indexPathString, data]) => {\n    const parentIndexPathString = parseIndexPath(indexPathString).slice(0, -1).join(\".\")\n\n    return {\n      data,\n      parentId: parentIndexPathString,\n      id: indexPathString,\n    }\n  })\n  const tree = arrayToTree(parsedValues, { dataField: null })\n  const cleanedTree = cleanAndSortTree({ children: tree })\n\n  return cleanedTree ? cleanedTree.children : []\n}\n\n/** Sorts a map by an indexPathString property. */\nexport function sortMapByIndexPath(treeMap: Map<string, any>) {\n  const sortedEntries = Array.from(treeMap.entries()).sort((a, b) => compareIndexPaths(a[0], b[0]))\n\n  return new Map(sortedEntries)\n}\n\n/** Flattens all tree nodes into one array. */\nexport function flattenChildren(children: any[]) {\n  const flatChildren = children.flatMap((child) =>\n    child.children ? flattenChildren(child.children) : [child]\n  )\n\n  return flatChildren\n}\n","import * as React from \"react\"\n\n/**\n * Manage an active index that needs to be contained or wrap.\n *\n * @example\n * const {\n *   activeIndex,\n *   moveActiveIndex,\n * } = useRovingIndex({ maxIndex: items.length - 1 })\n */\nexport function useRovingIndex({\n  contain = true,\n  defaultIndex = 0,\n  maxIndex = Infinity,\n  wrap = false,\n}: {\n  /** The default index used when first mounting. */\n  defaultIndex?: number\n\n  /** The max index used to know when to contain or wrap. */\n  contain?: boolean\n\n  /** The max index used to know when to contain or wrap. */\n  maxIndex?: number\n\n  /** Wrap index when navigating outside the first or last index. */\n  wrap?: boolean\n}): {\n  /** The active index. */\n  activeIndex: number\n\n  /** Whether the active index can be moved backward. */\n  moveBackwardDisabled: boolean\n\n  /** Whether the active index can be moved forward. */\n  moveForwardDisabled: boolean\n\n  /** Move the index backwards. */\n  moveBackward: () => void\n\n  /** Move the index forwards. */\n  moveForward: () => void\n\n  /** Move the active index by a positive or negative amount. */\n  moveActiveIndex: (amount: number) => void\n\n  /** Set any active index. */\n  setActiveIndex: (nextIndex: number) => void\n} {\n  const [activeIndex, setLocalActiveIndex] = React.useState(defaultIndex)\n  const getNextIndex = React.useCallback(\n    (nextIndex) => {\n      if (wrap) {\n        return ((nextIndex % maxIndex) + maxIndex) % maxIndex\n      }\n      if (contain) {\n        return nextIndex > maxIndex ? maxIndex : nextIndex < 0 ? 0 : nextIndex\n      }\n      return nextIndex\n    },\n    [maxIndex, wrap]\n  )\n  const moveActiveIndex = React.useCallback(\n    (amountToMove) => {\n      setLocalActiveIndex((currentIndex) => getNextIndex(currentIndex + amountToMove))\n    },\n    [getNextIndex]\n  )\n  const setActiveIndex = React.useCallback(\n    (nextIndex) => {\n      setLocalActiveIndex(getNextIndex(nextIndex))\n    },\n    [getNextIndex]\n  )\n  const moveBackward = React.useCallback(() => moveActiveIndex(-1), [moveActiveIndex])\n  const moveForward = React.useCallback(() => moveActiveIndex(1), [moveActiveIndex])\n\n  return {\n    activeIndex,\n    moveActiveIndex,\n    setActiveIndex,\n    moveBackward,\n    moveForward,\n    moveBackwardDisabled: activeIndex <= 0,\n    moveForwardDisabled: activeIndex >= maxIndex,\n  }\n}\n","import * as React from \"react\"\nimport { create } from \"zustand\"\n\nimport type { TreeState, TreeStateStore } from \"./contexts\"\nimport { PrerenderContext, TreeStateContext } from \"./contexts\"\nimport { useIndex, useIndexedChildren } from \"./use-indexed-children\"\nimport { sortMapByIndexPath, useIsomorphicLayoutEffect } from \"./utils\"\n\n/**\n * Control tree state from outside a component.\n *\n * @example\n * import type { TreeMap } from \"reforest\"\n * import { useTree, useTreeNode, useTreeMap } from \"reforest\"\n *\n * function Item({ children, value }) {\n *   useTreeNode(value)\n *   return <li>{children}</li>\n * }\n *\n * function ItemList({ children }: { children: React.ReactNode, treeState: TreeState }) {\n *   const tree = useTree(children, treeState)\n *   return <ul>{tree.children}</ul>\n * }\n *\n * function App() {\n *   const treeState = useTreeState()\n *   return (\n *     <ItemList treeState={treeState}>\n *       <Item value=\"apple\">Apple</Item>\n *       <Item value=\"banana\">Banana</Item>\n *       <Item value=\"cherry\">Cherry</Item>\n *     </ItemList>\n *   )\n * }\n */\nexport function useTreeState(): TreeStateStore\nexport function useTreeState<U>(selector: (state: TreeState) => U): U\nexport function useTreeState(selector?: (state: TreeState) => unknown) {\n  const treeStateContext = React.useContext(TreeStateContext)\n  const [treeState] = React.useState(\n    () =>\n      treeStateContext ||\n      create<TreeState>((set, get) => ({\n        treeMap: new Map(),\n        prerenderedTreeIds: new Map(),\n        shouldPrerender: true,\n        setTreeData: (id, data) => {\n          const { treeMap } = get()\n\n          treeMap.set(id, data)\n\n          set({ treeMap: sortMapByIndexPath(treeMap) })\n        },\n        deleteTreeData: (id) => {\n          const { treeMap } = get()\n\n          treeMap.delete(id)\n\n          set({ treeMap: sortMapByIndexPath(treeMap) })\n        },\n      }))\n  )\n\n  return selector ? treeState(selector) : treeState\n}\n\n/** Prerenders children to capture data in useTreeNode hooks for initial component renders. */\nfunction PrerenderTree({ children }: { children: React.ReactNode }) {\n  const treeState = useTreeState()\n  const shouldPrerender = treeState((state) => state.shouldPrerender)\n\n  useIsomorphicLayoutEffect(() => {\n    treeState.setState({\n      prerenderedTreeIds: new Map(),\n      shouldPrerender: false,\n    })\n  }, [])\n\n  return shouldPrerender ? (\n    <PrerenderContext.Provider value={true}>{children}</PrerenderContext.Provider>\n  ) : null\n}\n\n/** Determine if the current render is a prerender. */\nexport function usePrerender() {\n  const isPrerender = React.useContext(PrerenderContext)\n\n  if (isPrerender === null) {\n    throw new Error(\"usePrerender must be used in a descendant component of useTree.\")\n  }\n\n  return isPrerender\n}\n\n/**\n * Manage ordered data subscriptions for components.\n *\n * @example create a tree of data subscriptions\n * import { useTree, useTreeNode } from \"reforest\"\n *\n * function Item({ children, value }) {\n *   useTreeNode(value)\n *   return <li>{children}</li>\n * }\n *\n * function ItemList({ children }: { children: React.ReactNode }) {\n *   const tree = useTree(children)\n *   return <ul>{tree.children}</ul>\n * }\n */\nexport function useTree(children: React.ReactNode, treeState?: TreeStateStore) {\n  const treeStateContext = React.useContext(TreeStateContext)\n  const treeStateLocal = useTreeState()\n  const parsedTreeState = treeStateContext || treeState || treeStateLocal\n  const isPrerender = React.useContext(PrerenderContext)\n  const isRoot = treeStateContext === null\n  const indexedChildren = useIndexedChildren(children)\n  const childrenToRender = isRoot ? (\n    <TreeStateContext.Provider value={parsedTreeState}>\n      <PrerenderTree>{indexedChildren}</PrerenderTree>\n      {indexedChildren}\n    </TreeStateContext.Provider>\n  ) : (\n    indexedChildren\n  )\n\n  return {\n    children: childrenToRender,\n    useStore: parsedTreeState,\n    isPrerender,\n    isRoot,\n  }\n}\n\n/** Generate an id for use with useTreeNode. */\nexport function useTreeId() {\n  const treeStateContext = React.useContext(TreeStateContext)\n\n  if (treeStateContext === null) {\n    throw new Error(\"useTreeId must be used in a descendant component of useTree.\")\n  }\n\n  const { prerenderedTreeIds } = treeStateContext.getState()\n  const { indexPathString } = useIndex()!\n  const generatedId = React.useId().slice(1, -1)\n  const treeId = prerenderedTreeIds.get(indexPathString) || generatedId\n\n  return treeId\n}\n\n/** Subscribe data to the root useTree hook. */\nexport function useTreeNode(\n  treeId: string,\n  getData: () => any,\n  dependencies: React.DependencyList = []\n) {\n  const isPrerender = React.useContext(PrerenderContext)\n  const treeStateContext = React.useContext(TreeStateContext)\n\n  if (treeStateContext === null) {\n    throw new Error(\"useTreeNode must be used in a descendant component of useTree.\")\n  }\n\n  const { deleteTreeData, prerenderedTreeIds, setTreeData, treeMap } = treeStateContext.getState()\n  const { indexPathString } = useIndex()!\n  const treeData = React.useMemo(\n    () => Object.assign({ treeId }, getData()),\n    dependencies.concat(treeId)\n  )\n\n  if (isPrerender) {\n    /** Mutate tree data when prerendering so it's available when doing the subsequent render of root children. */\n    treeMap.set(indexPathString, treeData)\n\n    /** Store the treeId so there's a stable id between prerender and actual render. */\n    prerenderedTreeIds.set(indexPathString, treeId)\n  } else {\n    /** After the initial prerender we switch to a simple effect for coordinating data updates. */\n    React.useEffect(() => {\n      setTreeData(indexPathString, treeData)\n\n      return () => {\n        deleteTreeData(indexPathString)\n      }\n    }, [indexPathString, treeData])\n  }\n\n  return treeData\n}\n"],"mappings":"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","names":["React","React","React","React"]}